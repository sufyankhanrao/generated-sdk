"""paginationtester.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from apimatic_core.pagination.strategies.cursor_pagination import (
    CursorPagination,
)
from apimatic_core.pagination.strategies.link_pagination import (
    LinkPagination,
)
from apimatic_core.pagination.strategies.offset_pagination import (
    OffsetPagination,
)
from apimatic_core.pagination.strategies.page_pagination import (
    PagePagination,
)
from apimatic_core.request_builder import RequestBuilder
from apimatic_core.response_handler import ResponseHandler
from apimatic_core.types.parameter import Parameter

from paginationtester.api_helper import APIHelper
from paginationtester.configuration import Server
from paginationtester.controllers.base_controller import (
    BaseController,
)
from paginationtester.http.http_method_enum import (
    HttpMethodEnum,
)
from paginationtester.models.transactions import (
    Transactions,
)
from paginationtester.models.transactions_cursored import (
    TransactionsCursored,
)
from paginationtester.models.transactions_offset import (
    TransactionsOffset,
)
from paginationtester.utilities.pagination.paged_iterable import (
    PagedIterable,
)
from paginationtester.utilities.pagination.paged_response import (
    CursorPagedResponse,
    LinkPagedResponse,
    NumberPagedResponse,
    OffsetPagedResponse,
)


class TransactionController(BaseController):
    """A Controller to access Endpoints in the paginationtester API."""

    def __init__(self, config):
        """Initialize TransactionController object."""
        super(TransactionController, self).__init__(config)

    def fetch_with_offset(self,
                          offset=None,
                          limit=None,
                          success_on_empty_page=None):
        """Perform a GET request to /transactions/offset.

        Fetch transactions using Offset-based Pagination

        Args:
            offset (int, optional): The number of records to skip before
                selecting transactions.
            limit (int, optional): Number of transactions per page.
            success_on_empty_page (bool, optional): Should return 200 success
                code on the calls after the last batch of paginated data.

        Returns:
            PagedIterable: An instance of PagedIterable, to be used as an
                iterator. Paginated list of transactions (Offset-based)

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """
        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path("/transactions/offset")
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key("offset")
                         .value(offset))
            .query_param(Parameter()
                         .key("limit")
                         .value(limit))
            .query_param(Parameter()
                         .key("successOnEmptyPage")
                         .value(success_on_empty_page))
            .header_param(Parameter()
                          .key("accept")
                          .value("application/json")),
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(TransactionsOffset.from_dictionary)
            .is_api_response(True),
        ).pagination_strategies(
            OffsetPagination(
                "$request.query#/offset",
                lambda _response, _offset: OffsetPagedResponse.create(
                    _response, lambda _obj: _obj.data, _offset),
            ),
        ).paginate(
            lambda _paginated_data: PagedIterable(_paginated_data),
            lambda _response: _response.data,
        )

    def fetch_with_cursor(self,
                          cursor=None,
                          limit=10,
                          success_on_empty_page=None):
        """Perform a GET request to /transactions/cursor.

        Fetch transactions using Cursor-based Pagination

        Args:
            cursor (str, optional): The unique identifier (cursor) to fetch
                the next set of results.
            limit (int, optional): Number of transactions per page.
            success_on_empty_page (bool, optional): Should return 200 success
                code on the calls after the last batch of paginated data.

        Returns:
            PagedIterable: An instance of PagedIterable, to be used as an
                iterator. Paginated list of transactions (Cursor-based)

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """
        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path("/transactions/cursor")
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key("cursor")
                         .value(cursor))
            .query_param(Parameter()
                         .key("limit")
                         .value(limit))
            .query_param(Parameter()
                         .key("successOnEmptyPage")
                         .value(success_on_empty_page))
            .header_param(Parameter()
                          .key("accept")
                          .value("application/json")),
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(TransactionsCursored.from_dictionary)
            .is_api_response(True),
        ).pagination_strategies(
            CursorPagination(
                "$response.body#/nextCursor",
                "$request.query#/cursor",
                lambda _response, _cursor: CursorPagedResponse.create(
                    _response, lambda _obj: _obj.data, _cursor),
            ),
        ).paginate(
            lambda _paginated_data: PagedIterable(_paginated_data),
            lambda _response: _response.data,
        )

    def fetch_with_link(self,
                        page=1,
                        size=10,
                        success_on_empty_page=None):
        """Perform a GET request to /transactions/links.

        Fetch transactions using Link-based Pagination

        Args:
            page (int, optional): The page number to fetch.
            size (int, optional): Number of transactions per page.
            success_on_empty_page (bool, optional): Should return 200 success
                code on the calls after the last batch of paginated data.

        Returns:
            PagedIterable: An instance of PagedIterable, to be used as an
                iterator. Paginated list of transactions (Link-based)

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """
        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path("/transactions/links")
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key("page")
                         .value(page))
            .query_param(Parameter()
                         .key("size")
                         .value(size))
            .query_param(Parameter()
                         .key("successOnEmptyPage")
                         .value(success_on_empty_page))
            .header_param(Parameter()
                          .key("accept")
                          .value("application/json")),
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(Transactions.from_dictionary)
            .is_api_response(True),
        ).pagination_strategies(
            LinkPagination(
                "$response.body#/links/next",
                lambda _response, _link: LinkPagedResponse.create(
                    _response, lambda _obj: _obj.data, _link),
            ),
            PagePagination(
                "$request.query#/page",
                lambda _response, _page_no: NumberPagedResponse.create(
                    _response, lambda _obj: _obj.data, _page_no),
            ),
        ).paginate(
            lambda _paginated_data: PagedIterable(_paginated_data),
            lambda _response: _response.data,
        )

    def fetch_with_page(self,
                        page=None,
                        size=None,
                        success_on_empty_page=None):
        """Perform a GET request to /transactions/pages.

        Fetch transactions using Page-based Pagination

        Args:
            page (int, optional): The page number to fetch.
            size (int, optional): Number of transactions per page.
            success_on_empty_page (bool, optional): Should return 200 success
                code on the calls after the last batch of paginated data.

        Returns:
            PagedIterable: An instance of PagedIterable, to be used as an
                iterator. Paginated list of transactions (Page-based)

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """
        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path("/transactions/pages")
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key("page")
                         .value(page))
            .query_param(Parameter()
                         .key("size")
                         .value(size))
            .query_param(Parameter()
                         .key("successOnEmptyPage")
                         .value(success_on_empty_page))
            .header_param(Parameter()
                          .key("accept")
                          .value("application/json")),
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(Transactions.from_dictionary)
            .is_api_response(True),
        ).pagination_strategies(
            LinkPagination(
                "$response.body#/links/next",
                lambda _response, _link: LinkPagedResponse.create(
                    _response, lambda _obj: _obj.data, _link),
            ),
            PagePagination(
                "$request.query#/page",
                lambda _response, _page_no: NumberPagedResponse.create(
                    _response, lambda _obj: _obj.data, _page_no),
            ),
        ).paginate(
            lambda _paginated_data: PagedIterable(_paginated_data),
            lambda _response: _response.data,
        )
