"""testerxml.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from testerxml.utilities.xml_utilities import (
    XmlUtilities,
)


class SimpleAttributes(object):
    """Implementation of the 'SimpleAttributes' model.

    A model with only attributes (attributes can only be non-array primitive types)

    Attributes:
        string_element (str): string attribute (node name "string")
        nonreserved (str): string attribute (node name "nonreserved")
        number_element (int): number attribute (node name "number ")
        precision (float): precision attribute (node name "precision")
        boolean_element (bool): boolean attribute (node name "boolean")
        attributes_type (str): The model property of type str.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "string_element": "string-element",
        "nonreserved": "nonreserved",
        "number_element": "number-element",
        "precision": "precision",
        "boolean_element": "boolean-element",
        "attributes_type": "attributes_type",
    }

    _optionals = [
        "attributes_type",
    ]

    def __init__(
        self,
        string_element=None,
        nonreserved=None,
        number_element=None,
        precision=None,
        boolean_element=None,
        attributes_type="SimpleAttributes"):
        """Initialize a SimpleAttributes instance."""
        # Initialize members of the class
        self.string_element = string_element
        self.nonreserved = nonreserved
        self.number_element = number_element
        self.precision = precision
        self.boolean_element = boolean_element
        self.attributes_type = attributes_type

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        discriminators = {
            "ModelWithInheritedAttributes": ModelWithInheritedAttributes.from_element,
        }
        unboxer = discriminators.get(dictionary.get("attributes_type"))

        # Delegate unboxing to another function if a discriminator
        # value for a child class is present.
        if unboxer:
            return unboxer(dictionary)

        # Extract variables from the dictionary
        string_element =\
            dictionary.get("string-element")\
            if dictionary.get("string-element")\
                else None
        nonreserved =\
            dictionary.get("nonreserved")\
            if dictionary.get("nonreserved")\
                else None
        number_element =\
            dictionary.get("number-element")\
            if dictionary.get("number-element")\
                else None
        precision =\
            dictionary.get("precision")\
            if dictionary.get("precision")\
                else None
        boolean_element =\
            dictionary.get("boolean-element")\
            if "boolean-element" in dictionary.keys()\
                else None
        attributes_type =\
            dictionary.get("attributes_type")\
            if dictionary.get("attributes_type")\
                else "SimpleAttributes"

        # Return an object of this model
        return cls(string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   attributes_type)

    @classmethod
    def from_element(cls, root):
        """Initialize an instance of this class using an xml.etree.Element.

        Args:
            root (string): The root xml element.

        Returns:
            object: An instance of this class.

        """
        discriminators = {
            "ModelWithInheritedAttributes": ModelWithInheritedAttributes.from_element,
        }
        unboxer = discriminators.get(XmlUtilities.value_from_xml_element(root.find("attributes_type"), str))

        # Delegate unboxing to another function if a discriminator
        # value for a child class is present.
        if unboxer:
            return unboxer(root)

        string_element = XmlUtilities.value_from_xml_attribute(root.get("string"), str)
        nonreserved = XmlUtilities.value_from_xml_attribute(root.get("nonreserved"), str)
        number_element = XmlUtilities.value_from_xml_attribute(root.get("number"), int)
        precision = XmlUtilities.value_from_xml_attribute(root.get("precision"), float)
        boolean_element = XmlUtilities.value_from_xml_attribute(root.get("boolean"), bool)
        attributes_type = XmlUtilities.value_from_xml_element(root.find("attributes_type"), str)

        return cls(string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   attributes_type)

    def to_xml_sub_element(self, root):
        """Convert this object to an instance of xml.etree.Element.

        Args:
            root (xml.etree.Element): The parent of this xml element.

        """
        XmlUtilities.add_as_attribute(root, self.string_element, "string")
        XmlUtilities.add_as_attribute(root, self.nonreserved, "nonreserved")
        XmlUtilities.add_as_attribute(root, self.number_element, "number")
        XmlUtilities.add_as_attribute(root, self.precision, "precision")
        XmlUtilities.add_as_attribute(root, self.boolean_element, "boolean")
        XmlUtilities.add_as_subelement(root, self.attributes_type, "attributes_type")

    def __repr__(self):
        """Return a unambiguous string representation."""
        _string_element=self.string_element
        _nonreserved=self.nonreserved
        _number_element=self.number_element
        _precision=self.precision
        _boolean_element=self.boolean_element
        _attributes_type=(
            self.attributes_type
            if hasattr(self, "attributes_type")
            else None
        )
        return (
            f"{self.__class__.__name__}("
            f"string_element={_string_element!r}"
            f"nonreserved={_nonreserved!r}"
            f"number_element={_number_element!r}"
            f"precision={_precision!r}"
            f"boolean_element={_boolean_element!r}"
            f"attributes_type={_attributes_type!r}"
            f")"
        )

    def __str__(self):
        """Return a human-readable string representation."""
        _string_element=self.string_element
        _nonreserved=self.nonreserved
        _number_element=self.number_element
        _precision=self.precision
        _boolean_element=self.boolean_element
        _attributes_type=(
            self.attributes_type
            if hasattr(self, "attributes_type")
            else None
        )
        return (
            f"{self.__class__.__name__}("
            f"string_element={_string_element!s}"
            f"nonreserved={_nonreserved!s}"
            f"number_element={_number_element!s}"
            f"precision={_precision!s}"
            f"boolean_element={_boolean_element!s}"
            f"attributes_type={_attributes_type!s}"
            f")"
        )

class ModelWithInheritedAttributes(SimpleAttributes):
    """Implementation of the 'ModelWithInheritedAttributes' model.
    NOTE: This class inherits from 'SimpleAttributes'.

    Attributes:
        new_string_field (str): String attribute with the name

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "new_string_field": "NewStringField",
        "string_element": "string-element",
        "nonreserved": "nonreserved",
        "number_element": "number-element",
        "precision": "precision",
        "boolean_element": "boolean-element",
        "attributes_type": "attributes_type",
    }

    def __init__(
        self,
        new_string_field=None,
        string_element=None,
        nonreserved=None,
        number_element=None,
        precision=None,
        boolean_element=None,
        attributes_type="ModelWithInheritedAttributes"):
        """Initialize a ModelWithInheritedAttributes instance."""
        # Initialize members of the class
        self.new_string_field = new_string_field

        # Call the constructor for the base class
        super(ModelWithInheritedAttributes, self).__init__(
            string_element,
            nonreserved,
            number_element,
            precision,
            boolean_element,
            attributes_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        new_string_field =\
            dictionary.get("NewStringField")\
            if dictionary.get("NewStringField")\
                else None
        string_element =\
            dictionary.get("string-element")\
            if dictionary.get("string-element")\
                else None
        nonreserved =\
            dictionary.get("nonreserved")\
            if dictionary.get("nonreserved")\
                else None
        number_element =\
            dictionary.get("number-element")\
            if dictionary.get("number-element")\
                else None
        precision =\
            dictionary.get("precision")\
            if dictionary.get("precision")\
                else None
        boolean_element =\
            dictionary.get("boolean-element")\
            if "boolean-element" in dictionary.keys()\
                else None
        attributes_type =\
            dictionary.get("attributes_type")\
            if dictionary.get("attributes_type")\
                else "ModelWithInheritedAttributes"

        # Return an object of this model
        return cls(new_string_field,
                   string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   attributes_type)

    @classmethod
    def from_element(cls, root):
        """Initialize an instance of this class using an xml.etree.Element.

        Args:
            root (string): The root xml element.

        Returns:
            object: An instance of this class.

        """
        new_string_field = XmlUtilities.value_from_xml_attribute(root.get("NewStringField"), str)
        string_element = XmlUtilities.value_from_xml_attribute(root.get("string"), str)
        nonreserved = XmlUtilities.value_from_xml_attribute(root.get("nonreserved"), str)
        number_element = XmlUtilities.value_from_xml_attribute(root.get("number"), int)
        precision = XmlUtilities.value_from_xml_attribute(root.get("precision"), float)
        boolean_element = XmlUtilities.value_from_xml_attribute(root.get("boolean"), bool)
        attributes_type = XmlUtilities.value_from_xml_element(root.find("attributes_type"), str)

        return cls(new_string_field,
                   string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   attributes_type)

    def to_xml_sub_element(self, root):
        """Convert this object to an instance of xml.etree.Element.

        Args:
            root (xml.etree.Element): The parent of this xml element.

        """
        XmlUtilities.add_as_attribute(root, self.new_string_field, "NewStringField")
        XmlUtilities.add_as_attribute(root, self.string_element, "string")
        XmlUtilities.add_as_attribute(root, self.nonreserved, "nonreserved")
        XmlUtilities.add_as_attribute(root, self.number_element, "number")
        XmlUtilities.add_as_attribute(root, self.precision, "precision")
        XmlUtilities.add_as_attribute(root, self.boolean_element, "boolean")
        XmlUtilities.add_as_subelement(root, self.attributes_type, "attributes_type")

    def __repr__(self):
        """Return a unambiguous string representation."""
        _new_string_field=self.new_string_field
        _base_repr = super().__repr__()
        _base_repr = _base_repr[_base_repr.find("(") + 1:-1]
        return (
            f"{self.__class__.__name__}("
            f"base_repr={_base_repr!r}"
            f"new_string_field={_new_string_field!r}"
            f")"
        )

    def __str__(self):
        """Return a human-readable string representation."""
        _new_string_field=self.new_string_field
        _base_str = super().__str__()
        _base_str = _base_str[_base_str.find("(") + 1:-1]
        return (
            f"{self.__class__.__name__}("
            f"base_str={_base_str!s}"
            f"new_string_field={_new_string_field!s}"
            f")"
        )
