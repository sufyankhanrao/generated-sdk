"""testerxml.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from testerxml.utilities.xml_utilities import (
    XmlUtilities,
)


class SimpleElements(object):
    """Implementation of the 'SimpleElements' model.

    A model with only non-array, primitive type elements. Look
    [here](https://gist.github.com/thehappybug/f6cf13f8b5c14a9079ed6402fffe6861
    #generate-simple-object) for the expected xml schema

    Attributes:
        string_element (str): string element (element name "string")
        nonreserved (str): string element (element name "nonreserved")
        number_element (int): number element (element name "number ")
        precision (float): precision element (element name "precision")
        boolean_element (bool): boolean element (element name "boolean")
        model_type (str): The model property of type str.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "string_element": "string-element",
        "nonreserved": "nonreserved",
        "number_element": "number-element",
        "precision": "precision",
        "boolean_element": "boolean-element",
        "model_type": "model_type",
    }

    _optionals = [
        "model_type",
    ]

    def __init__(self,
                 string_element=None,
                 nonreserved=None,
                 number_element=None,
                 precision=None,
                 boolean_element=None,
                 model_type="SimpleElements"):
        """Initialize a SimpleElements instance."""
        # Initialize members of the class
        self.string_element = string_element
        self.nonreserved = nonreserved
        self.number_element = number_element
        self.precision = precision
        self.boolean_element = boolean_element
        self.model_type = model_type

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        discriminators = {
            "ModelWithInheritedElements": ModelWithInheritedElements.from_element,
        }
        unboxer = discriminators.get(dictionary.get("model_type"))

        # Delegate unboxing to another function if a discriminator
        # value for a child class is present.
        if unboxer:
            return unboxer(dictionary)

        # Extract variables from the dictionary
        string_element =\
            dictionary.get("string-element")\
            if dictionary.get("string-element") else None
        nonreserved =\
            dictionary.get("nonreserved")\
            if dictionary.get("nonreserved") else None
        number_element =\
            dictionary.get("number-element")\
            if dictionary.get("number-element") else None
        precision =\
            dictionary.get("precision")\
            if dictionary.get("precision") else None
        boolean_element =\
            dictionary.get("boolean-element")\
            if "boolean-element" in dictionary.keys() else None
        model_type =\
            dictionary.get("model_type")\
            if dictionary.get("model_type") else "SimpleElements"
        # Return an object of this model
        return cls(string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   model_type)

    @classmethod
    def from_element(cls, root):
        """Initialize an instance of this class using an xml.etree.Element.

        Args:
            root (string): The root xml element.

        Returns:
            object: An instance of this class.

        """
        discriminators = {
            "ModelWithInheritedElements": ModelWithInheritedElements.from_element,
        }
        unboxer = discriminators.get(XmlUtilities.value_from_xml_element(root.find("model_type"), str))

        # Delegate unboxing to another function if a discriminator
        # value for a child class is present.
        if unboxer:
            return unboxer(root)

        string_element = XmlUtilities.value_from_xml_element(root.find("string"), str)
        nonreserved = XmlUtilities.value_from_xml_element(root.find("nonreserved"), str)
        number_element = XmlUtilities.value_from_xml_element(root.find("number"), int)
        precision = XmlUtilities.value_from_xml_element(root.find("precision"), float)
        boolean_element = XmlUtilities.value_from_xml_element(root.find("boolean"), bool)
        model_type = XmlUtilities.value_from_xml_element(root.find("model_type"), str)

        return cls(string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   model_type)

    def to_xml_sub_element(self, root):
        """Convert this object to an instance of xml.etree.Element.

        Args:
            root (xml.etree.Element): The parent of this xml element.

        """
        XmlUtilities.add_as_subelement(root, self.string_element, "string")
        XmlUtilities.add_as_subelement(root, self.nonreserved, "nonreserved")
        XmlUtilities.add_as_subelement(root, self.number_element, "number")
        XmlUtilities.add_as_subelement(root, self.precision, "precision")
        XmlUtilities.add_as_subelement(root, self.boolean_element, "boolean")
        XmlUtilities.add_as_subelement(root, self.model_type, "model_type")

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"string_element={self.string_element!r}, "
                f"nonreserved={self.nonreserved!r}, "
                f"number_element={self.number_element!r}, "
                f"precision={self.precision!r}, "
                f"boolean_element={self.boolean_element!r}, "
                f"model_type={(self.model_type
                     if hasattr(self, 'model_type') else None)!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"string_element={self.string_element!s}, "
                f"nonreserved={self.nonreserved!s}, "
                f"number_element={self.number_element!s}, "
                f"precision={self.precision!s}, "
                f"boolean_element={self.boolean_element!s}, "
                f"model_type={(self.model_type
                     if hasattr(self, 'model_type') else None)!s})")

class ModelWithInheritedElements(SimpleElements):
    """Implementation of the 'ModelWithInheritedElements' model.
    NOTE: This class inherits from 'SimpleElements'.

    Attributes:
        new_string_field (str): String attribute with the name

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "new_string_field": "NewStringField",
        "string_element": "string-element",
        "nonreserved": "nonreserved",
        "number_element": "number-element",
        "precision": "precision",
        "boolean_element": "boolean-element",
        "model_type": "model_type",
    }

    def __init__(self,
                 new_string_field=None,
                 string_element=None,
                 nonreserved=None,
                 number_element=None,
                 precision=None,
                 boolean_element=None,
                 model_type="ModelWithInheritedElements"):
        """Initialize a ModelWithInheritedElements instance."""
        # Initialize members of the class
        self.new_string_field = new_string_field

        # Call the constructor for the base class
        super(ModelWithInheritedElements, self).__init__(string_element,
                                                         nonreserved,
                                                         number_element,
                                                         precision,
                                                         boolean_element,
                                                         model_type)

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        new_string_field =\
            dictionary.get("NewStringField")\
            if dictionary.get("NewStringField") else None
        string_element =\
            dictionary.get("string-element")\
            if dictionary.get("string-element") else None
        nonreserved =\
            dictionary.get("nonreserved")\
            if dictionary.get("nonreserved") else None
        number_element =\
            dictionary.get("number-element")\
            if dictionary.get("number-element") else None
        precision =\
            dictionary.get("precision")\
            if dictionary.get("precision") else None
        boolean_element =\
            dictionary.get("boolean-element")\
            if "boolean-element" in dictionary.keys() else None
        model_type =\
            dictionary.get("model_type")\
            if dictionary.get("model_type") else "ModelWithInheritedElements"
        # Return an object of this model
        return cls(new_string_field,
                   string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   model_type)

    @classmethod
    def from_element(cls, root):
        """Initialize an instance of this class using an xml.etree.Element.

        Args:
            root (string): The root xml element.

        Returns:
            object: An instance of this class.

        """
        new_string_field = XmlUtilities.value_from_xml_element(root.find("NewStringField"), str)
        string_element = XmlUtilities.value_from_xml_element(root.find("string"), str)
        nonreserved = XmlUtilities.value_from_xml_element(root.find("nonreserved"), str)
        number_element = XmlUtilities.value_from_xml_element(root.find("number"), int)
        precision = XmlUtilities.value_from_xml_element(root.find("precision"), float)
        boolean_element = XmlUtilities.value_from_xml_element(root.find("boolean"), bool)
        model_type = XmlUtilities.value_from_xml_element(root.find("model_type"), str)

        return cls(new_string_field,
                   string_element,
                   nonreserved,
                   number_element,
                   precision,
                   boolean_element,
                   model_type)

    def to_xml_sub_element(self, root):
        """Convert this object to an instance of xml.etree.Element.

        Args:
            root (xml.etree.Element): The parent of this xml element.

        """
        XmlUtilities.add_as_subelement(root, self.new_string_field, "NewStringField")
        XmlUtilities.add_as_subelement(root, self.string_element, "string")
        XmlUtilities.add_as_subelement(root, self.nonreserved, "nonreserved")
        XmlUtilities.add_as_subelement(root, self.number_element, "number")
        XmlUtilities.add_as_subelement(root, self.precision, "precision")
        XmlUtilities.add_as_subelement(root, self.boolean_element, "boolean")
        XmlUtilities.add_as_subelement(root, self.model_type, "model_type")

    def __repr__(self):
        """Return a unambiguous string representation."""
        base_repr = super().__repr__()
        return (f"{self.__class__.__name__}("
                f"{base_repr[base_repr.find('(') + 1:-1]}, "
                f"new_string_field={self.new_string_field!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        base_str = super().__str__()
        return (f"{self.__class__.__name__}("
                f"{base_str[base_str.find('(') + 1:-1]}, "
                f"new_string_field={self.new_string_field!s})")
