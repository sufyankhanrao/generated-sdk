"""
 webhooksandcallbacksapi

 This file was automatically generated by APIMATIC v3.0 (
https://www.apimatic.io ).
"""

from __future__ import annotations

from typing import (
    Optional,
    Union
)

from apimatic_core.security.signature_verifiers.hmac_signature_verifier import (
    HmacSignatureVerifier
)

from webhooksandcallbacksapi.api_helper import (
    APIHelper
)
from webhooksandcallbacksapi.events.signature_verification_failure import (
    SignatureVerificationFailure
)
from webhooksandcallbacksapi.events.signature_verification_result import (
    SignatureVerificationResult
)
from webhooksandcallbacksapi.events.unknown_event import (
    UnknownEvent
)
from webhooksandcallbacksapi.http.request import (
    Request
)
from webhooksandcallbacksapi.models.notification_callback import (
    NotificationCallback
)
from webhooksandcallbacksapi.utilities.union_type_lookup import (
    UnionTypeLookUp
)

CallbacksBEventType = Union[NotificationCallback, SignatureVerificationFailure, UnknownEvent]

class CallbacksBHandler:
    """
     Notification delivery callback group with discriminator mapping
    """

    def __init__(self, secret_key: str) -> None:
        """
         Initializes the handler.

        :param secret_key: The secret used to generate and validate HMAC
                           signatures for verifying request authenticity.
        :type secret_key: str
        """

        if not secret_key:
            raise ValueError(
                "secret_key must be provided for signature verification.",
            )
        self._verifier = HmacSignatureVerifier(
            secret_key=secret_key,
            signature_header="X-Signature",
            canonical_message_builder=self._canonical_message_builder,
        )

    def verify(self, request: Request) -> SignatureVerificationResult:
        """
         Perform signature verification and return the result.

        :param request: The incoming HTTP request to verify.
        :type request: Request

        :return: The result of the signature verification.
        :rtype: SignatureVerificationResult
        """

        return self._verifier.verify(request)

    def verify_and_parse_event(self, request: Request) -> CallbacksBEventType:
        """
         Verify the request signature and parse the event.

        :return: NotificationCallback for successful parsing;
                 SignatureVerificationFailure when signature fails; UnknownEvent
                 for unknown events.
        :rtype: Union[NotificationCallback, SignatureVerificationFailure,
                UnknownEvent]
        """

        if request is None or not hasattr(request, "headers") or not hasattr(request, "raw_body"):
            return SignatureVerificationFailure(["Invalid request object."])
        if request.headers is None or not hasattr(request.headers, "items"):
            return SignatureVerificationFailure(["Invalid headers."])
        verification_result = self.verify(request)
        if not verification_result.ok:
            return SignatureVerificationFailure(verification_result.errors)
        # Deserialize payload
        try:
            union = UnionTypeLookUp.get("callbacksB")
            return APIHelper.deserialize_union_type(union, request.raw_body)
        except Exception as e:
            return UnknownEvent(["Deserialization failed.", str(e)])

    @staticmethod
    def _canonical_message_builder(request: Request) -> Optional[bytes]:
        """
         Builds the canonical message from the request for the signature
        verification.

        :param request: The incoming HTTP request.
        :type request: Request

        :return: The canonical message as bytes, or None if the message could
                 not be constructed.
        :rtype: Optional[bytes]
        """

        payload = request.raw_body.decode()
        notification_type = APIHelper.get_value_by_json_pointer(
            APIHelper.json_deserialize(payload), "notificationType"
        )
        return f"{notification_type}".encode()
