# -*- coding: utf-8 -*-

"""
shellev

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from shellev.api_helper import APIHelper
from shellev.models.coordinates import Coordinates


class MultiLocationMarker(object):

    """Implementation of the 'MultiLocationMarker' model.

    A Marker is a place on the map that represent multiple Locations at the
    same spot

    Attributes:
        marker_type (str): Identifies the marker type. If it's a
            `MultiLocationMarker`, then the value is `MultiLocation`
        unique_key (str): Uniquely identifies the marker object
        coordinates (Coordinates): Coordinates of the Shell Recharge Site
            Location
        location_count (float): Number of Locations that this Marker
            represents in the given set of bounds
        evse_count (float): Total number of Evses in Locations that this
            Marker represents
        max_power (float): Maximum power in kW across all locations grouped in
            this marker (disregarding availability)
        geo_hash (str): GeoHash of marker coordinates

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "marker_type": 'markerType',
        "unique_key": 'uniqueKey',
        "coordinates": 'coordinates',
        "location_count": 'locationCount',
        "evse_count": 'evseCount',
        "max_power": 'maxPower',
        "geo_hash": 'geoHash'
    }

    _optionals = [
        'unique_key',
        'coordinates',
        'location_count',
        'evse_count',
        'max_power',
        'geo_hash',
    ]

    def __init__(self,
                 marker_type=None,
                 unique_key=APIHelper.SKIP,
                 coordinates=APIHelper.SKIP,
                 location_count=APIHelper.SKIP,
                 evse_count=APIHelper.SKIP,
                 max_power=APIHelper.SKIP,
                 geo_hash=APIHelper.SKIP):
        """Constructor for the MultiLocationMarker class"""

        # Initialize members of the class
        self.marker_type = marker_type 
        if unique_key is not APIHelper.SKIP:
            self.unique_key = unique_key 
        if coordinates is not APIHelper.SKIP:
            self.coordinates = coordinates 
        if location_count is not APIHelper.SKIP:
            self.location_count = location_count 
        if evse_count is not APIHelper.SKIP:
            self.evse_count = evse_count 
        if max_power is not APIHelper.SKIP:
            self.max_power = max_power 
        if geo_hash is not APIHelper.SKIP:
            self.geo_hash = geo_hash 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        marker_type = dictionary.get("markerType") if dictionary.get("markerType") else None
        unique_key = dictionary.get("uniqueKey") if dictionary.get("uniqueKey") else APIHelper.SKIP
        coordinates = Coordinates.from_dictionary(dictionary.get('coordinates')) if 'coordinates' in dictionary.keys() else APIHelper.SKIP
        location_count = dictionary.get("locationCount") if dictionary.get("locationCount") else APIHelper.SKIP
        evse_count = dictionary.get("evseCount") if dictionary.get("evseCount") else APIHelper.SKIP
        max_power = dictionary.get("maxPower") if dictionary.get("maxPower") else APIHelper.SKIP
        geo_hash = dictionary.get("geoHash") if dictionary.get("geoHash") else APIHelper.SKIP
        # Return an object of this model
        return cls(marker_type,
                   unique_key,
                   coordinates,
                   location_count,
                   evse_count,
                   max_power,
                   geo_hash)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(value=dictionary.marker_type,
                                           type_callable=lambda value: isinstance(value, str))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(value=dictionary.get('markerType'),
                                       type_callable=lambda value: isinstance(value, str))

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'marker_type={self.marker_type!r}, '
                f'unique_key={(self.unique_key if hasattr(self, "unique_key") else None)!r}, '
                f'coordinates={(self.coordinates if hasattr(self, "coordinates") else None)!r}, '
                f'location_count={(self.location_count if hasattr(self, "location_count") else None)!r}, '
                f'evse_count={(self.evse_count if hasattr(self, "evse_count") else None)!r}, '
                f'max_power={(self.max_power if hasattr(self, "max_power") else None)!r}, '
                f'geo_hash={(self.geo_hash if hasattr(self, "geo_hash") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'marker_type={self.marker_type!s}, '
                f'unique_key={(self.unique_key if hasattr(self, "unique_key") else None)!s}, '
                f'coordinates={(self.coordinates if hasattr(self, "coordinates") else None)!s}, '
                f'location_count={(self.location_count if hasattr(self, "location_count") else None)!s}, '
                f'evse_count={(self.evse_count if hasattr(self, "evse_count") else None)!s}, '
                f'max_power={(self.max_power if hasattr(self, "max_power") else None)!s}, '
                f'geo_hash={(self.geo_hash if hasattr(self, "geo_hash") else None)!s})')
