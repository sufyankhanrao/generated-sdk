# -*- coding: utf-8 -*-

"""
goeapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from goeapi.api_helper import APIHelper


class RunPipeAnalysisReport(object):

    """Implementation of the 'RunPipeAnalysisReport' model.

    Attributes:
        current_goal_probability (float): GOE’s estimated probability to
            achieve the goal target wealth. This is rounded to 4 decimal
            places.
        current_loss_threshold_probability (float): GOE’s estimated
            probability to remain above the loss threshold amount by the end
            of the goal tenure. <br>             This is rounded to 4 decimal
            places.
        p_delta_current_goal_probability (float): This probability refers to
            the goal probability simulation results. This parameter uses a
            random variable, <br>         and each run returns a slightly
            different result. This is rounded to 4 decimal places.
        p_delta_current_loss_threshold_probability (float): Like the p-delta
            goal probability, this is only used for simulation purposes. It
            simulates the goal's loss threshold probability.         This is
            rounded to 4 decimal places.
        recommended_portfolio_id (int): GOE’s current recommended portfolio
            index. <br>                     Note: Portfolio chosen from the
            list of all available portfolios to the goal.
        meet_goal_priority (bool): Checks if goal probability is more than the
            target probability corresponding to <br>         the goal priority
            – Target probabilities for all goal priorities (Need, Want, Wish
            and Dream) are set in the GOE config. <br>         Note: If
            ‘true’, goal probability achieves the target probability – goal
            probability to be shown on the front end. <br>         If ‘false’,
            goal probability falls short of the target probability –goal
            probability to be shown along with infusion and tenure
            recommendations
        is_goal_realistic (bool): To understand if the goal can be met with a
            reasonable probability (set by the ‘unrealistic’ goal probability
            value in the GOE config).<br>         If current goal probability
            < desired target goal probability (defined by the goal priority),
            the goal is termed unrealistic <br>         Note: Flag will be set
            to False if the current goal probability is less than the
            probability threshold for realistic goal for all cases
            irrespective. <br>         If ‘false’, goal is unrealistic - need
            to alert the user on the front end with a message such as ‘Goal is
            not realistic, please try reducing your target <br>         goal
            amount or increasing your initial investment’
        meet_loss_priority (bool): Checks if loss probability is more than the
            target loss probability (target set in the GOE config) <br>       
            Note: If true, estimated loss probability meets the target loss
            probability
        one_time_top_up (float): Suggested one-time top-up amount that aims to
            improve the goal probability to meet the target goal
            probability.<br>                     This is rounded to the
            nearest integer.
        yearly_top_up_accumulation (float): Suggested recurring yearly top-up
            amount that aims to improve the goal probability to meet the
            target goal probability. <br> This would be returned with a value
            if the infusionType is annual. This is rounded to the nearest
            integer. This would be 0 if infusionType is monthly. <br> Note:
            Zero in cases where meet goal priority = ‘true’; Non-zero
            otherwise.
        monthly_top_up_accumulation (float): Suggested recurring monthly
            top-up amount during the accumulation period that aims to improve
            <br>              the goal probability to meet the target goal
            probability. This would be returned only if the infusionType is
            monthly. <br>             This is rounded to the nearest integer.
            <br>             Note: Zero in cases where meet goal priority =
            ‘true’; Non-zero otherwise.
        yearly_top_up_decumulation (float): Suggested recurring yearly
            decumulation amount that aims to improve the goal probability to
            meet the target goal probability. <br>            This would be
            returned only if the infusionType is annual. This is rounded to
            the nearest integer.
        monthly_top_up_decumulation (float): Suggested recurring monthly
            top-up decumulation amount that aims to improve the goal
            probability to meet the target <br>        goal probability, this
            value would be populated only in cases of decumulation of
            withdrawal scenario. This would be returned only <br>        if
            the infusionType is monthly. This is rounded to the nearest
            integer.
        recommended_tenure (str): For scenarios with goal probability less
            than 50%: <br>                     • If original tenure between 1
            - 8 years –extended/reduced tenure 2 years to 4 years <br>        
            • If original tenure between 9 – 14 years – extended/reduced
            tenure 4 years to 8 years <br>                     • If original
            tenure greater than equal to 15 years –extended/reduced tenure 5
            years to 10 years <br>         For scenarios with goal probability
            greater than or equal to 50%, extended/reduced tenure = 2 years to
            4 years for all cases.<br>         The algorithm recommends
            standard tenure increments/decrements based on the tenure input
            and the goal probability (calculated using current and end
            date).<br>         Cases where tenure recommendation isn’t
            valid/required will show the recommendation as NA. <br>        For
            retirement cases, where there is accumulation followed by
            decumulation, the extension is based on years to retirement and
            not on original tenure
        bankruptcy_msg (str): Message flagging an expected bankruptcy (goal
            running out of money) in any year.<br>         The algorithm
            recommends standard tenure increments/decrements based on the
            tenure input and the goal probability (calculated using current
            and end date). <br>        Note: If ‘NA’, bankruptcy is unlikely
            to happen during the goal tenure.In bankruptcy cases, response
            would be similar to <br>        ‘Bankruptcy is likely to happen in
            year 1’.
        recommended_final_wealth_at_75 (float): This is an optional parameter
            .If the target wealth were to be reduced by 25% of the difference
            between the target and the current wealth.<br>         Applicable
            for non-retirement scenarios with tenures less than or equal to 30
            years. This is rounded to the nearest integer <br>        Note: To
            be denoted as a rounded number with a currency suffix ($980,384)
            on the front end.
        recommended_prob_at_75 (float): Goal probability corresponding to
            ‘recommended final wealth at 75%’ above.<br>         Applicable
            for non-retirement scenarios with tenures less than or equal to 30
            years. This is rounded to the nearest integer.<br>        Note: To
            be denoted as a rounded number with no decimals, on the front end.
        recommended_final_wealth_at_50 (float): This is an optional parameter
            .If the target wealth were to be reduced by 50% of the difference
            between the target and the current wealth.<br>         Applicable
            for non-retirement scenarios with tenures less than or equal to 30
            years. This is rounded to the nearest integer <br>        Note: To
            be denoted as a rounded number with a currency suffix ($960,769)
            on the front end.
        recommended_prob_at_50 (float): Goal probability corresponding to
            ‘recommended final wealth at 50%’ above.<br>         Applicable
            for non-retirement scenarios with tenures less than or equal to 30
            years. This is rounded to the nearest integer.<br>        Note: To
            be denoted as a rounded number with no decimals, on the front end.
        advisor_discretion_report (Dict[str, float]): Recommended Portfolio
            and corresponding probability.<br>         In case where current
            portfolio is not null, it provides the following:<br>        1.
            Probability of attaining goal (using the current portfolio sent as
            an input and a constant portfolio path) – Monte Carlo
            simulations<br>         2. 2. Current Goal Probability (dynamic
            asset allocation by GOE) and the recommended portfolio <br>       
            In case the current portfolio is null, the current goal
            probability is displayed (using dynamic asset allocation by GOE
            <br>        and not assuming a constant portfolio path) along with
            the recommended portfolio.
        message (str): Captures any message from the API after it is done
            processing the request.
        loss_threshold (int): Loss threshold value – the wealth amount that
            the investor does not want to end up below at the end of the goal
            tenure.<br>         If the input parameter ‘lossThreshold’ is not
            passed or value is ‘null’, this parameter is calculated by
            GOE.<br>         If the input parameter ‘lossThreshold’ is a
            number value, GOE will consider this as the loss threshold.
        additional_properties (Dict[str, Any]): The additional properties for
            the model.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "current_goal_probability": 'currentGoalProbability',
        "current_loss_threshold_probability": 'currentLossThresholdProbability',
        "p_delta_current_goal_probability": 'pDeltaCurrentGoalProbability',
        "p_delta_current_loss_threshold_probability": 'pDeltaCurrentLossThresholdProbability',
        "recommended_portfolio_id": 'recommendedPortfolioId',
        "meet_goal_priority": 'meetGoalPriority',
        "is_goal_realistic": 'isGoalRealistic',
        "meet_loss_priority": 'meetLossPriority',
        "one_time_top_up": 'oneTimeTopUp',
        "yearly_top_up_accumulation": 'yearlyTopUpAccumulation',
        "monthly_top_up_accumulation": 'monthlyTopUpAccumulation',
        "yearly_top_up_decumulation": 'yearlyTopUpDecumulation',
        "monthly_top_up_decumulation": 'monthlyTopUpDecumulation',
        "recommended_tenure": 'recommendedTenure',
        "bankruptcy_msg": 'bankruptcyMsg',
        "advisor_discretion_report": 'advisorDiscretionReport',
        "message": 'message',
        "loss_threshold": 'lossThreshold',
        "recommended_final_wealth_at_75": 'recommendedFinalWealthAt75',
        "recommended_prob_at_75": 'recommendedProbAt75',
        "recommended_final_wealth_at_50": 'recommendedFinalWealthAt50',
        "recommended_prob_at_50": 'recommendedProbAt50'
    }

    _optionals = [
        'recommended_final_wealth_at_75',
        'recommended_prob_at_75',
        'recommended_final_wealth_at_50',
        'recommended_prob_at_50',
    ]

    _nullables = [
        'current_goal_probability',
        'current_loss_threshold_probability',
        'p_delta_current_goal_probability',
        'p_delta_current_loss_threshold_probability',
        'meet_goal_priority',
        'is_goal_realistic',
        'meet_loss_priority',
        'one_time_top_up',
        'yearly_top_up_accumulation',
        'monthly_top_up_accumulation',
        'yearly_top_up_decumulation',
        'monthly_top_up_decumulation',
        'recommended_tenure',
        'bankruptcy_msg',
        'advisor_discretion_report',
        'message',
        'loss_threshold',
    ]

    def __init__(self,
                 current_goal_probability=None,
                 current_loss_threshold_probability=None,
                 p_delta_current_goal_probability=None,
                 p_delta_current_loss_threshold_probability=None,
                 recommended_portfolio_id=None,
                 meet_goal_priority=None,
                 is_goal_realistic=None,
                 meet_loss_priority=None,
                 one_time_top_up=None,
                 yearly_top_up_accumulation=None,
                 monthly_top_up_accumulation=None,
                 yearly_top_up_decumulation=None,
                 monthly_top_up_decumulation=None,
                 recommended_tenure=None,
                 bankruptcy_msg=None,
                 advisor_discretion_report=None,
                 message=None,
                 loss_threshold=None,
                 recommended_final_wealth_at_75=APIHelper.SKIP,
                 recommended_prob_at_75=APIHelper.SKIP,
                 recommended_final_wealth_at_50=APIHelper.SKIP,
                 recommended_prob_at_50=APIHelper.SKIP,
                 additional_properties=None):
        """Constructor for the RunPipeAnalysisReport class"""

        # Initialize members of the class
        self.current_goal_probability = current_goal_probability 
        self.current_loss_threshold_probability = current_loss_threshold_probability 
        self.p_delta_current_goal_probability = p_delta_current_goal_probability 
        self.p_delta_current_loss_threshold_probability = p_delta_current_loss_threshold_probability 
        self.recommended_portfolio_id = recommended_portfolio_id 
        self.meet_goal_priority = meet_goal_priority 
        self.is_goal_realistic = is_goal_realistic 
        self.meet_loss_priority = meet_loss_priority 
        self.one_time_top_up = one_time_top_up 
        self.yearly_top_up_accumulation = yearly_top_up_accumulation 
        self.monthly_top_up_accumulation = monthly_top_up_accumulation 
        self.yearly_top_up_decumulation = yearly_top_up_decumulation 
        self.monthly_top_up_decumulation = monthly_top_up_decumulation 
        self.recommended_tenure = recommended_tenure 
        self.bankruptcy_msg = bankruptcy_msg 
        if recommended_final_wealth_at_75 is not APIHelper.SKIP:
            self.recommended_final_wealth_at_75 = recommended_final_wealth_at_75 
        if recommended_prob_at_75 is not APIHelper.SKIP:
            self.recommended_prob_at_75 = recommended_prob_at_75 
        if recommended_final_wealth_at_50 is not APIHelper.SKIP:
            self.recommended_final_wealth_at_50 = recommended_final_wealth_at_50 
        if recommended_prob_at_50 is not APIHelper.SKIP:
            self.recommended_prob_at_50 = recommended_prob_at_50 
        self.advisor_discretion_report = advisor_discretion_report 
        self.message = message 
        self.loss_threshold = loss_threshold 

        # Add additional model properties to the instance
        if additional_properties is None:
            additional_properties = {}
        self.additional_properties = additional_properties

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        current_goal_probability = dictionary.get("currentGoalProbability") if dictionary.get("currentGoalProbability") else None
        current_loss_threshold_probability = dictionary.get("currentLossThresholdProbability") if dictionary.get("currentLossThresholdProbability") else None
        p_delta_current_goal_probability = dictionary.get("pDeltaCurrentGoalProbability") if dictionary.get("pDeltaCurrentGoalProbability") else None
        p_delta_current_loss_threshold_probability = dictionary.get("pDeltaCurrentLossThresholdProbability") if dictionary.get("pDeltaCurrentLossThresholdProbability") else None
        recommended_portfolio_id = dictionary.get("recommendedPortfolioId") if dictionary.get("recommendedPortfolioId") else None
        meet_goal_priority = dictionary.get("meetGoalPriority") if "meetGoalPriority" in dictionary.keys() else None
        is_goal_realistic = dictionary.get("isGoalRealistic") if "isGoalRealistic" in dictionary.keys() else None
        meet_loss_priority = dictionary.get("meetLossPriority") if "meetLossPriority" in dictionary.keys() else None
        one_time_top_up = dictionary.get("oneTimeTopUp") if dictionary.get("oneTimeTopUp") else None
        yearly_top_up_accumulation = dictionary.get("yearlyTopUpAccumulation") if dictionary.get("yearlyTopUpAccumulation") else None
        monthly_top_up_accumulation = dictionary.get("monthlyTopUpAccumulation") if dictionary.get("monthlyTopUpAccumulation") else None
        yearly_top_up_decumulation = dictionary.get("yearlyTopUpDecumulation") if dictionary.get("yearlyTopUpDecumulation") else None
        monthly_top_up_decumulation = dictionary.get("monthlyTopUpDecumulation") if dictionary.get("monthlyTopUpDecumulation") else None
        recommended_tenure = dictionary.get("recommendedTenure") if dictionary.get("recommendedTenure") else None
        bankruptcy_msg = dictionary.get("bankruptcyMsg") if dictionary.get("bankruptcyMsg") else None
        advisor_discretion_report = dictionary.get("advisorDiscretionReport") if dictionary.get("advisorDiscretionReport") else None
        message = dictionary.get("message") if dictionary.get("message") else None
        loss_threshold = dictionary.get("lossThreshold") if dictionary.get("lossThreshold") else None
        recommended_final_wealth_at_75 = dictionary.get("recommendedFinalWealthAt75") if dictionary.get("recommendedFinalWealthAt75") else APIHelper.SKIP
        recommended_prob_at_75 = dictionary.get("recommendedProbAt75") if dictionary.get("recommendedProbAt75") else APIHelper.SKIP
        recommended_final_wealth_at_50 = dictionary.get("recommendedFinalWealthAt50") if dictionary.get("recommendedFinalWealthAt50") else APIHelper.SKIP
        recommended_prob_at_50 = dictionary.get("recommendedProbAt50") if dictionary.get("recommendedProbAt50") else APIHelper.SKIP
        additional_properties = APIHelper.get_additional_properties(
            dictionary={k: v for k, v in dictionary.items() if k not in cls._names.values()},
            unboxing_function=lambda value: value)
        # Return an object of this model
        return cls(current_goal_probability,
                   current_loss_threshold_probability,
                   p_delta_current_goal_probability,
                   p_delta_current_loss_threshold_probability,
                   recommended_portfolio_id,
                   meet_goal_priority,
                   is_goal_realistic,
                   meet_loss_priority,
                   one_time_top_up,
                   yearly_top_up_accumulation,
                   monthly_top_up_accumulation,
                   yearly_top_up_decumulation,
                   monthly_top_up_decumulation,
                   recommended_tenure,
                   bankruptcy_msg,
                   advisor_discretion_report,
                   message,
                   loss_threshold,
                   recommended_final_wealth_at_75,
                   recommended_prob_at_75,
                   recommended_final_wealth_at_50,
                   recommended_prob_at_50,
                   additional_properties)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'current_goal_probability={self.current_goal_probability!r}, '
                f'current_loss_threshold_probability={self.current_loss_threshold_probability!r}, '
                f'p_delta_current_goal_probability={self.p_delta_current_goal_probability!r}, '
                f'p_delta_current_loss_threshold_probability={self.p_delta_current_loss_threshold_probability!r}, '
                f'recommended_portfolio_id={self.recommended_portfolio_id!r}, '
                f'meet_goal_priority={self.meet_goal_priority!r}, '
                f'is_goal_realistic={self.is_goal_realistic!r}, '
                f'meet_loss_priority={self.meet_loss_priority!r}, '
                f'one_time_top_up={self.one_time_top_up!r}, '
                f'yearly_top_up_accumulation={self.yearly_top_up_accumulation!r}, '
                f'monthly_top_up_accumulation={self.monthly_top_up_accumulation!r}, '
                f'yearly_top_up_decumulation={self.yearly_top_up_decumulation!r}, '
                f'monthly_top_up_decumulation={self.monthly_top_up_decumulation!r}, '
                f'recommended_tenure={self.recommended_tenure!r}, '
                f'bankruptcy_msg={self.bankruptcy_msg!r}, '
                f'recommended_final_wealth_at_75={(self.recommended_final_wealth_at_75 if hasattr(self, "recommended_final_wealth_at_75") else None)!r}, '
                f'recommended_prob_at_75={(self.recommended_prob_at_75 if hasattr(self, "recommended_prob_at_75") else None)!r}, '
                f'recommended_final_wealth_at_50={(self.recommended_final_wealth_at_50 if hasattr(self, "recommended_final_wealth_at_50") else None)!r}, '
                f'recommended_prob_at_50={(self.recommended_prob_at_50 if hasattr(self, "recommended_prob_at_50") else None)!r}, '
                f'advisor_discretion_report={self.advisor_discretion_report!r}, '
                f'message={self.message!r}, '
                f'loss_threshold={self.loss_threshold!r}, '
                f'additional_properties={self.additional_properties!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'current_goal_probability={self.current_goal_probability!s}, '
                f'current_loss_threshold_probability={self.current_loss_threshold_probability!s}, '
                f'p_delta_current_goal_probability={self.p_delta_current_goal_probability!s}, '
                f'p_delta_current_loss_threshold_probability={self.p_delta_current_loss_threshold_probability!s}, '
                f'recommended_portfolio_id={self.recommended_portfolio_id!s}, '
                f'meet_goal_priority={self.meet_goal_priority!s}, '
                f'is_goal_realistic={self.is_goal_realistic!s}, '
                f'meet_loss_priority={self.meet_loss_priority!s}, '
                f'one_time_top_up={self.one_time_top_up!s}, '
                f'yearly_top_up_accumulation={self.yearly_top_up_accumulation!s}, '
                f'monthly_top_up_accumulation={self.monthly_top_up_accumulation!s}, '
                f'yearly_top_up_decumulation={self.yearly_top_up_decumulation!s}, '
                f'monthly_top_up_decumulation={self.monthly_top_up_decumulation!s}, '
                f'recommended_tenure={self.recommended_tenure!s}, '
                f'bankruptcy_msg={self.bankruptcy_msg!s}, '
                f'recommended_final_wealth_at_75={(self.recommended_final_wealth_at_75 if hasattr(self, "recommended_final_wealth_at_75") else None)!s}, '
                f'recommended_prob_at_75={(self.recommended_prob_at_75 if hasattr(self, "recommended_prob_at_75") else None)!s}, '
                f'recommended_final_wealth_at_50={(self.recommended_final_wealth_at_50 if hasattr(self, "recommended_final_wealth_at_50") else None)!s}, '
                f'recommended_prob_at_50={(self.recommended_prob_at_50 if hasattr(self, "recommended_prob_at_50") else None)!s}, '
                f'advisor_discretion_report={self.advisor_discretion_report!s}, '
                f'message={self.message!s}, '
                f'loss_threshold={self.loss_threshold!s}, '
                f'additional_properties={self.additional_properties!s})')
