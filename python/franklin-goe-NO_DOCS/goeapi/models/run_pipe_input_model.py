"""goeapi.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from goeapi.api_helper import APIHelper


class RunPipeInputModel(object):
    """Implementation of the 'RunPipeInputModel' model.

    Attributes:
        is_new_goal_priority (bool): If investor/end user changes the goal
            priority in between the re-allocation dates, <br>
            this is set to ‘true’. For first time calls to GOE, this needs to
            be set to ‘true’.
        is_new_investment_tenure (bool): If investor/end user changes the goal
            investment tenure after onboarding and before the next immediate
            re-allocation date,<br>                                     this
            is set to ‘true’. For first time calls to GOE, this needs to be
            set to ‘true’.
        is_new_risk_profile (bool): If the risk profile of the investor has
            changed, this should be set to ‘true’.<br>                    For
            first time calls to GOE, this needs to be set to ‘true’.
        is_new_goal (bool): If investor/end user changes the goal amount, in
            between the re-allocation dates, this is set to ‘true’. <br>
            For retirement scenarios, this would be a change in retirement
            income goal, while for a capital accumulation goal,
            this would be a change in the lumpsum accumulation target. For
            first time calls to GOE, this needs to be set to ‘true’.
        reallocate (bool): If the client wants GOE to reallocate between the
            scheduled re-allocation dates, this should be set to ‘true’.
        cashflow_date (str): Cashflow date of the goal - this is the date
            (year is ignored) on which infusions/withdrawals <br>
            would be realized for the goal. Format is "dd-mm-yyyy" <br>
            If not passed or value is null, the algorithm would consider the
            first reallocation date as the cashflow date.
        loss_threshold (float): Loss threshold value – the wealth amount that
            the investor does not want to end up below at the end of the goal
            tenure.<br>                                                 If not
            passed or value is ‘null’, the GOE algo would calculate the loss
            threshold. If a number value is passed, GOE would consider that
            amount as the loss threshold.<br>
            If loss threshold is not available, this needs to be passed as
            ‘null’, and GOE would calculate the loss threshold and return as a
            part of the response ‘loss threshold’. <br>
            This amount needs to be stored, and should be passed as
            ‘lossThreshold’ on subsequent GOE calls.
        get_path (bool): Show ideal portfolio path over time. If getPath
            parameter is set to False, the portfolio path would not be
            returned in the response payload
        reallocation_freq (ReallocationFreq): Describes the frequency of
            re-allocation.
        goal_amount (float): Defines the target wealth value associated with
            the goal at end of goal tenure.
        initial_investment (float): Defines the initial investment amount to
            the goal.
        current_wealth (float): Current wealth when the GOE is being called or
            executed. At the time of initial onboarding, currentWealth =
            initialInvestment. <br>
            At subsequent re-allocation dates, currentWealth would be the
            portfolio account value at the time.
        start_date (str): Defines the start date of goal.Valid input format is
            date – ‘dd-mm-yyyy’
        end_date (str): Defines the end date of goal.Valid input format is
            date – ‘dd-mm-yyyy’
        curr_date (str): This is an optional parameter that can be used to
            simulate the current date to be the specified value. <br>
            GOE will process the request as if you are making the API call on
            the specified date. <br>                     If not passed, the
            current system date will be used as the current date.<br>
            Valid input format is date – ‘dd-mm-yyyy’.
        goal_priority (GoalPriority): Defines the importance a goal holds for
            a specific user. Order of priority is Need > Want > Wish > Dream
            <br>         goalPriority can be from 1 to 4 levels. However, note
            that Goal priority defines the target probabilities and the loss
            threshold values.
        current_portfolio_id (int): Displays the current portfolio index that
            the goal is allocated to; <br>                    if GOE is
            getting executed for the first time, it should be null.
        infusions (List[float]): Cash flows from the user, recurring payments
            yearly <br>
            The length for this parameter is dynamic depending on the goal
            tenure, start date and end date.<br>
            The reference will always be on the created date. So, the first
            infusion will be on the first day of the goal <br>
            followed by infusions every year/month followed by the last
            infusion/withdrawal on the last day of the goal.<br>
            The values are positive in case of infusions; negative in case of
            withdrawals; zero in case of no cashflows; frequency depends on
            ‘infusion_type’ parameter
        risk_profile (RiskProfile6): Defines the user’s risk profile – does
            not vary by goal for each investor. <br>             On a default
            basis, GOE is configured for three Risk Profile levels, but it can
            be customized for up to five levels. <br>             Note that
            Risk Profiles are mapped to portfolio access.This is nullable and
            non mandatory if useAgeBasedCap is true
        scenario_type (ScenarioType1): Determines the type of the scenario,
            the suggested portfolio and the wealth glide path is created
            accordingly. <br>                     ‘regular’ for regular goals
            accumulation goals where cash flows are positive (contributions)
            and with a typical target wealth <br>
            ‘retirement’ for scenarios where a decumulation period is
            included: <br>                     1. Scenarios with an
            accumulation period (and an initial wealth) & positive cash flows
            followed <br>                     by a decumulation period with
            withdrawals (negative cash flows) with or without an inheritance
            <br>                     2. Scenarios with an initial wealth
            followed by a decumulation period with or without an inheritance.
        infusion_type (InfusionType): Indicates the frequency of cash flows –
            determines the cash flow array corresponding to the ‘infusions’
            parameter.
        current_age (int): Captures the current age of the investor. <br>
            Optional Parameter.Need to be passed if ‘useAgeBasedCap’ is set to
            True or ‘requiredDataAvailable’ is set to False.
        retirement_age (int): Captures the retirement age of the investor.
            <br>                 Optional Parameter.Considered as 65 if not
            passed
        risk_override (bool): This is an optional parameter to disable GOE’s
            default de-risking logic. <br>                     When set to
            False, GOE considers the default de-risking logic.the goal and the
            allocation advice <br>                     When set to True, GOE
            will not consider the default de-risking logic and will consider
            the risk profile of the participant for portfolio access.
        engaged_participant (bool): This applies only to retirement use cases
            which specifies whether a participant is engaged or unengaged. If
            the “currentAge” and the <br>        “retirementAge” are passed,
            they will be used to determine the de-risking criteria; If set to
            true GOE <br>        will de-risk 5 years before retirement and if
            set to false GOE will de-risk 1 year before retirement as per the
            default admin configuration settings
        required_data_available (bool): This indicates to GOE if all the
            mandatory data parameters that are required to run the GOE
            algorithm are available or not.<br>          If all the mandatory
            fields are available, this parameter is set to true, and they need
            be passed to run GOE. <br>         If all the mandatory fields are
            not available, this parameter is set to false, and they need not
            be passed to run GOE except the 'currentAge' and <br>        the
            “retirementAge”; The API response body would contain only the
            recommended portfolio and the portfolio path, which is derived
            from a pre-determined glide path <br>        based on the current
            age and the retirement age (this would be defaulted to 65 if not
            passed). All other response parameters would be null.
        wealth_path_probabilities (List[float]): This is an optional input
            parameter. If this input is passed, instead of one wealth path,
            the GOE output will <br>         have 3 wealth paths –one path at
            the goal priority probability level and one path for each of the 2
            probability values passed in this input array.
        last_reallocation_probability (float): The goal probability as of last
            reallocation needs to be passed.
        last_reallocation_date (str): The date on which last reallocation call
            was made to GOE.Format - dd-mm-yyyy
        plan_id (str): Plan ID of the partipant.
        participant_id (str): ID of the partipant.
        source_id (str): Source ID of the plan
        use_age_based_cap (bool): This is an optional parameter set as false
            by default. If this is passed as <br>                     ‘true’ –
            the maximum number of portfolios at any age would be restricted
            based <br>                     on a pre-defined glide path based
            on the number years to retirement; <br>                     The
            ‘currentAge’ and ‘retirementAge’ become mandatory fields. This
            applies only to retirement goals.
        inflation (float): This is an optional field that when provided
            adjusts the yearly/monthly topup recommendations for inflation
        retirement_date (str): Optional parameter that can be used to identify
            periods where cashflow recommendations are applied.
            saveMore will be appied before and spendLess will be applied
            affter the retirement date.            Its format is 'dd-mm-yyyy'
        target_portfolio (int): Defines the portfolio ID that has to be held
            across the entire goal horizon <br>             during single
            portfolio mode i.e. buy and hold strategy. <br>
            Mandatory if mode is 'single-portfolio'​
        mode (str): Determines the custom modes that can be invoked by GOE API
        min_equity_allocation (float): Defines the minimum equity allocation
            for the GOE recommended portfolio.
        max_equity_allocation (float): Defines the maximum equity allocation
            for the GOE recommended portfolio.
        allocation_to_annuities (float): Specifies percenatage of wealth that
            the user has allocated to annuities externally.
        additional_properties (Dict[str, Any]): The additional properties for
            the model.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "is_new_goal_priority": "isNewGoalPriority",
        "is_new_investment_tenure": "isNewInvestmentTenure",
        "is_new_risk_profile": "isNewRiskProfile",
        "is_new_goal": "isNewGoal",
        "get_path": "getPath",
        "reallocation_freq": "reallocationFreq",
        "goal_amount": "goalAmount",
        "initial_investment": "initialInvestment",
        "current_wealth": "currentWealth",
        "start_date": "startDate",
        "end_date": "endDate",
        "goal_priority": "goalPriority",
        "current_portfolio_id": "currentPortfolioId",
        "infusions": "infusions",
        "risk_profile": "riskProfile",
        "scenario_type": "scenarioType",
        "infusion_type": "infusionType",
        "reallocate": "reallocate",
        "cashflow_date": "cashflowDate",
        "loss_threshold": "lossThreshold",
        "curr_date": "currDate",
        "current_age": "currentAge",
        "retirement_age": "retirementAge",
        "risk_override": "riskOverride",
        "engaged_participant": "engagedParticipant",
        "required_data_available": "requiredDataAvailable",
        "wealth_path_probabilities": "wealthPathProbabilities",
        "last_reallocation_probability": "lastReallocationProbability",
        "last_reallocation_date": "lastReallocationDate",
        "plan_id": "planID",
        "participant_id": "participantID",
        "source_id": "sourceID",
        "use_age_based_cap": "useAgeBasedCap",
        "inflation": "inflation",
        "retirement_date": "retirementDate",
        "target_portfolio": "targetPortfolio",
        "mode": "mode",
        "min_equity_allocation": "minEquityAllocation",
        "max_equity_allocation": "maxEquityAllocation",
        "allocation_to_annuities": "allocationToAnnuities",
    }

    _optionals = [
        "reallocate",
        "cashflow_date",
        "loss_threshold",
        "curr_date",
        "current_age",
        "retirement_age",
        "risk_override",
        "engaged_participant",
        "required_data_available",
        "wealth_path_probabilities",
        "last_reallocation_probability",
        "last_reallocation_date",
        "plan_id",
        "participant_id",
        "source_id",
        "use_age_based_cap",
        "inflation",
        "retirement_date",
        "target_portfolio",
        "mode",
        "min_equity_allocation",
        "max_equity_allocation",
        "allocation_to_annuities",
    ]

    _nullables = [
        "cashflow_date",
        "loss_threshold",
        "current_wealth",
        "curr_date",
        "current_portfolio_id",
        "current_age",
        "retirement_age",
        "risk_override",
        "engaged_participant",
        "wealth_path_probabilities",
        "last_reallocation_probability",
        "last_reallocation_date",
        "plan_id",
        "participant_id",
        "source_id",
        "inflation",
        "retirement_date",
        "target_portfolio",
        "mode",
        "min_equity_allocation",
        "max_equity_allocation",
    ]

    def __init__(self,
                 is_new_goal_priority=None,
                 is_new_investment_tenure=None,
                 is_new_risk_profile=None,
                 is_new_goal=None,
                 get_path=None,
                 reallocation_freq=None,
                 goal_amount=None,
                 initial_investment=None,
                 current_wealth=None,
                 start_date=None,
                 end_date=None,
                 goal_priority=None,
                 current_portfolio_id=None,
                 infusions=None,
                 risk_profile=None,
                 scenario_type=None,
                 infusion_type=None,
                 reallocate=False,
                 cashflow_date=APIHelper.SKIP,
                 loss_threshold=APIHelper.SKIP,
                 curr_date=APIHelper.SKIP,
                 current_age=APIHelper.SKIP,
                 retirement_age=APIHelper.SKIP,
                 risk_override=APIHelper.SKIP,
                 engaged_participant=APIHelper.SKIP,
                 required_data_available=True,
                 wealth_path_probabilities=APIHelper.SKIP,
                 last_reallocation_probability=APIHelper.SKIP,
                 last_reallocation_date=APIHelper.SKIP,
                 plan_id=APIHelper.SKIP,
                 participant_id=APIHelper.SKIP,
                 source_id=APIHelper.SKIP,
                 use_age_based_cap=False,
                 inflation=APIHelper.SKIP,
                 retirement_date=APIHelper.SKIP,
                 target_portfolio=APIHelper.SKIP,
                 mode=APIHelper.SKIP,
                 min_equity_allocation=APIHelper.SKIP,
                 max_equity_allocation=APIHelper.SKIP,
                 allocation_to_annuities=APIHelper.SKIP,
                 additional_properties=None):
        """Initialize a RunPipeInputModel instance."""
        # Initialize members of the class
        self.is_new_goal_priority = is_new_goal_priority
        self.is_new_investment_tenure = is_new_investment_tenure
        self.is_new_risk_profile = is_new_risk_profile
        self.is_new_goal = is_new_goal
        self.reallocate = reallocate
        if cashflow_date is not APIHelper.SKIP:
            self.cashflow_date = cashflow_date
        if loss_threshold is not APIHelper.SKIP:
            self.loss_threshold = loss_threshold
        self.get_path = get_path
        self.reallocation_freq = reallocation_freq
        self.goal_amount = goal_amount
        self.initial_investment = initial_investment
        self.current_wealth = current_wealth
        self.start_date = start_date
        self.end_date = end_date
        if curr_date is not APIHelper.SKIP:
            self.curr_date = curr_date
        self.goal_priority = goal_priority
        self.current_portfolio_id = current_portfolio_id
        self.infusions = infusions
        self.risk_profile = risk_profile
        self.scenario_type = scenario_type
        self.infusion_type = infusion_type
        if current_age is not APIHelper.SKIP:
            self.current_age = current_age
        if retirement_age is not APIHelper.SKIP:
            self.retirement_age = retirement_age
        if risk_override is not APIHelper.SKIP:
            self.risk_override = risk_override
        if engaged_participant is not APIHelper.SKIP:
            self.engaged_participant = engaged_participant
        self.required_data_available = required_data_available
        if wealth_path_probabilities is not APIHelper.SKIP:
            self.wealth_path_probabilities = wealth_path_probabilities
        if last_reallocation_probability is not APIHelper.SKIP:
            self.last_reallocation_probability = last_reallocation_probability
        if last_reallocation_date is not APIHelper.SKIP:
            self.last_reallocation_date = last_reallocation_date
        if plan_id is not APIHelper.SKIP:
            self.plan_id = plan_id
        if participant_id is not APIHelper.SKIP:
            self.participant_id = participant_id
        if source_id is not APIHelper.SKIP:
            self.source_id = source_id
        self.use_age_based_cap = use_age_based_cap
        if inflation is not APIHelper.SKIP:
            self.inflation = inflation
        if retirement_date is not APIHelper.SKIP:
            self.retirement_date = retirement_date
        if target_portfolio is not APIHelper.SKIP:
            self.target_portfolio = target_portfolio
        if mode is not APIHelper.SKIP:
            self.mode = mode
        if min_equity_allocation is not APIHelper.SKIP:
            self.min_equity_allocation = min_equity_allocation
        if max_equity_allocation is not APIHelper.SKIP:
            self.max_equity_allocation = max_equity_allocation
        if allocation_to_annuities is not APIHelper.SKIP:
            self.allocation_to_annuities = allocation_to_annuities

        # Add additional model properties to the instance
        if additional_properties is None:
            additional_properties = {}
        self.additional_properties = additional_properties

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        is_new_goal_priority =\
            dictionary.get("isNewGoalPriority")\
            if "isNewGoalPriority" in dictionary.keys() else None
        is_new_investment_tenure =\
            dictionary.get("isNewInvestmentTenure")\
            if "isNewInvestmentTenure" in dictionary.keys() else None
        is_new_risk_profile =\
            dictionary.get("isNewRiskProfile")\
            if "isNewRiskProfile" in dictionary.keys() else None
        is_new_goal =\
            dictionary.get("isNewGoal")\
            if "isNewGoal" in dictionary.keys() else None
        get_path =\
            dictionary.get("getPath")\
            if "getPath" in dictionary.keys() else None
        reallocation_freq =\
            dictionary.get("reallocationFreq")\
            if dictionary.get("reallocationFreq") else None
        goal_amount =\
            dictionary.get("goalAmount")\
            if dictionary.get("goalAmount") else None
        initial_investment =\
            dictionary.get("initialInvestment")\
            if dictionary.get("initialInvestment") else None
        current_wealth =\
            dictionary.get("currentWealth")\
            if dictionary.get("currentWealth") else None
        start_date =\
            dictionary.get("startDate")\
            if dictionary.get("startDate") else None
        end_date =\
            dictionary.get("endDate")\
            if dictionary.get("endDate") else None
        goal_priority =\
            dictionary.get("goalPriority")\
            if dictionary.get("goalPriority") else None
        current_portfolio_id =\
            dictionary.get("currentPortfolioId")\
            if dictionary.get("currentPortfolioId") else None
        infusions =\
            dictionary.get("infusions")\
            if dictionary.get("infusions") else None
        risk_profile =\
            dictionary.get("riskProfile")\
            if dictionary.get("riskProfile") else None
        scenario_type =\
            dictionary.get("scenarioType")\
            if dictionary.get("scenarioType") else None
        infusion_type =\
            dictionary.get("infusionType")\
            if dictionary.get("infusionType") else None
        reallocate =\
            dictionary.get("reallocate")\
            if dictionary.get("reallocate") else False
        cashflow_date =\
            dictionary.get("cashflowDate")\
            if "cashflowDate" in dictionary.keys() else APIHelper.SKIP
        loss_threshold =\
            dictionary.get("lossThreshold")\
            if "lossThreshold" in dictionary.keys() else APIHelper.SKIP
        curr_date =\
            dictionary.get("currDate")\
            if "currDate" in dictionary.keys() else APIHelper.SKIP
        current_age =\
            dictionary.get("currentAge")\
            if "currentAge" in dictionary.keys() else APIHelper.SKIP
        retirement_age =\
            dictionary.get("retirementAge")\
            if "retirementAge" in dictionary.keys() else APIHelper.SKIP
        risk_override =\
            dictionary.get("riskOverride")\
            if "riskOverride" in dictionary.keys() else APIHelper.SKIP
        engaged_participant =\
            dictionary.get("engagedParticipant")\
            if "engagedParticipant" in dictionary.keys() else APIHelper.SKIP
        required_data_available =\
            dictionary.get("requiredDataAvailable")\
            if dictionary.get("requiredDataAvailable") else True
        wealth_path_probabilities =\
            dictionary.get("wealthPathProbabilities")\
            if "wealthPathProbabilities" in dictionary.keys() else APIHelper.SKIP
        last_reallocation_probability =\
            dictionary.get("lastReallocationProbability")\
            if "lastReallocationProbability" in dictionary.keys() else APIHelper.SKIP
        last_reallocation_date =\
            dictionary.get("lastReallocationDate")\
            if "lastReallocationDate" in dictionary.keys() else APIHelper.SKIP
        plan_id =\
            dictionary.get("planID")\
            if "planID" in dictionary.keys() else APIHelper.SKIP
        participant_id =\
            dictionary.get("participantID")\
            if "participantID" in dictionary.keys() else APIHelper.SKIP
        source_id =\
            dictionary.get("sourceID")\
            if "sourceID" in dictionary.keys() else APIHelper.SKIP
        use_age_based_cap =\
            dictionary.get("useAgeBasedCap")\
            if dictionary.get("useAgeBasedCap") else False
        inflation =\
            dictionary.get("inflation")\
            if "inflation" in dictionary.keys() else APIHelper.SKIP
        retirement_date =\
            dictionary.get("retirementDate")\
            if "retirementDate" in dictionary.keys() else APIHelper.SKIP
        target_portfolio =\
            dictionary.get("targetPortfolio")\
            if "targetPortfolio" in dictionary.keys() else APIHelper.SKIP
        mode =\
            dictionary.get("mode")\
            if "mode" in dictionary.keys() else APIHelper.SKIP
        min_equity_allocation =\
            dictionary.get("minEquityAllocation")\
            if "minEquityAllocation" in dictionary.keys() else APIHelper.SKIP
        max_equity_allocation =\
            dictionary.get("maxEquityAllocation")\
            if "maxEquityAllocation" in dictionary.keys() else APIHelper.SKIP
        allocation_to_annuities =\
            dictionary.get("allocationToAnnuities")\
            if dictionary.get("allocationToAnnuities") else APIHelper.SKIP
        additional_properties = APIHelper.get_additional_properties(
            dictionary={k: v for k, v in dictionary.items() if k not in cls._names.values()},
            unboxing_function=lambda value: value)
        # Return an object of this model
        return cls(is_new_goal_priority,
                   is_new_investment_tenure,
                   is_new_risk_profile,
                   is_new_goal,
                   get_path,
                   reallocation_freq,
                   goal_amount,
                   initial_investment,
                   current_wealth,
                   start_date,
                   end_date,
                   goal_priority,
                   current_portfolio_id,
                   infusions,
                   risk_profile,
                   scenario_type,
                   infusion_type,
                   reallocate,
                   cashflow_date,
                   loss_threshold,
                   curr_date,
                   current_age,
                   retirement_age,
                   risk_override,
                   engaged_participant,
                   required_data_available,
                   wealth_path_probabilities,
                   last_reallocation_probability,
                   last_reallocation_date,
                   plan_id,
                   participant_id,
                   source_id,
                   use_age_based_cap,
                   inflation,
                   retirement_date,
                   target_portfolio,
                   mode,
                   min_equity_allocation,
                   max_equity_allocation,
                   allocation_to_annuities,
                   additional_properties)

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"is_new_goal_priority={self.is_new_goal_priority!r}, "
                f"is_new_investment_tenure={self.is_new_investment_tenure!r}, "
                f"is_new_risk_profile={self.is_new_risk_profile!r}, "
                f"is_new_goal={self.is_new_goal!r}, "
                f"reallocate={(self.reallocate
                     if hasattr(self, 'reallocate') else None)!r}, "
                f"cashflow_date={(self.cashflow_date
                     if hasattr(self, 'cashflow_date') else None)!r}, "
                f"loss_threshold={(self.loss_threshold
                     if hasattr(self, 'loss_threshold') else None)!r}, "
                f"get_path={self.get_path!r}, "
                f"reallocation_freq={self.reallocation_freq!r}, "
                f"goal_amount={self.goal_amount!r}, "
                f"initial_investment={self.initial_investment!r}, "
                f"current_wealth={self.current_wealth!r}, "
                f"start_date={self.start_date!r}, "
                f"end_date={self.end_date!r}, "
                f"curr_date={(self.curr_date
                     if hasattr(self, 'curr_date') else None)!r}, "
                f"goal_priority={self.goal_priority!r}, "
                f"current_portfolio_id={self.current_portfolio_id!r}, "
                f"infusions={self.infusions!r}, "
                f"risk_profile={self.risk_profile!r}, "
                f"scenario_type={self.scenario_type!r}, "
                f"infusion_type={self.infusion_type!r}, "
                f"current_age={(self.current_age
                     if hasattr(self, 'current_age') else None)!r}, "
                f"retirement_age={(self.retirement_age
                     if hasattr(self, 'retirement_age') else None)!r}, "
                f"risk_override={(self.risk_override
                     if hasattr(self, 'risk_override') else None)!r}, "
                f"engaged_participant={(self.engaged_participant
                     if hasattr(self, 'engaged_participant') else None)!r}, "
                f"required_data_available={(self.required_data_available
                     if hasattr(self, 'required_data_available') else None)!r}, "
                f"wealth_path_probabilities={(self.wealth_path_probabilities
                     if hasattr(self, 'wealth_path_probabilities') else None)!r}, "
                f"last_reallocation_probability={(self.last_reallocation_probability
                     if hasattr(self, 'last_reallocation_probability') else None)!r}, "
                f"last_reallocation_date={(self.last_reallocation_date
                     if hasattr(self, 'last_reallocation_date') else None)!r}, "
                f"plan_id={(self.plan_id
                     if hasattr(self, 'plan_id') else None)!r}, "
                f"participant_id={(self.participant_id
                     if hasattr(self, 'participant_id') else None)!r}, "
                f"source_id={(self.source_id
                     if hasattr(self, 'source_id') else None)!r}, "
                f"use_age_based_cap={(self.use_age_based_cap
                     if hasattr(self, 'use_age_based_cap') else None)!r}, "
                f"inflation={(self.inflation
                     if hasattr(self, 'inflation') else None)!r}, "
                f"retirement_date={(self.retirement_date
                     if hasattr(self, 'retirement_date') else None)!r}, "
                f"target_portfolio={(self.target_portfolio
                     if hasattr(self, 'target_portfolio') else None)!r}, "
                f"mode={(self.mode if hasattr(self, 'mode') else None)!r}, "
                f"min_equity_allocation={(self.min_equity_allocation
                     if hasattr(self, 'min_equity_allocation') else None)!r}, "
                f"max_equity_allocation={(self.max_equity_allocation
                     if hasattr(self, 'max_equity_allocation') else None)!r}, "
                f"allocation_to_annuities={(self.allocation_to_annuities
                     if hasattr(self, 'allocation_to_annuities') else None)!r}, "
                f"additional_properties={self.additional_properties!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"is_new_goal_priority={self.is_new_goal_priority!s}, "
                f"is_new_investment_tenure={self.is_new_investment_tenure!s}, "
                f"is_new_risk_profile={self.is_new_risk_profile!s}, "
                f"is_new_goal={self.is_new_goal!s}, "
                f"reallocate={(self.reallocate
                     if hasattr(self, 'reallocate') else None)!s}, "
                f"cashflow_date={(self.cashflow_date
                     if hasattr(self, 'cashflow_date') else None)!s}, "
                f"loss_threshold={(self.loss_threshold
                     if hasattr(self, 'loss_threshold') else None)!s}, "
                f"get_path={self.get_path!s}, "
                f"reallocation_freq={self.reallocation_freq!s}, "
                f"goal_amount={self.goal_amount!s}, "
                f"initial_investment={self.initial_investment!s}, "
                f"current_wealth={self.current_wealth!s}, "
                f"start_date={self.start_date!s}, "
                f"end_date={self.end_date!s}, "
                f"curr_date={(self.curr_date
                     if hasattr(self, 'curr_date') else None)!s}, "
                f"goal_priority={self.goal_priority!s}, "
                f"current_portfolio_id={self.current_portfolio_id!s}, "
                f"infusions={self.infusions!s}, "
                f"risk_profile={self.risk_profile!s}, "
                f"scenario_type={self.scenario_type!s}, "
                f"infusion_type={self.infusion_type!s}, "
                f"current_age={(self.current_age
                     if hasattr(self, 'current_age') else None)!s}, "
                f"retirement_age={(self.retirement_age
                     if hasattr(self, 'retirement_age') else None)!s}, "
                f"risk_override={(self.risk_override
                     if hasattr(self, 'risk_override') else None)!s}, "
                f"engaged_participant={(self.engaged_participant
                     if hasattr(self, 'engaged_participant') else None)!s}, "
                f"required_data_available={(self.required_data_available
                     if hasattr(self, 'required_data_available') else None)!s}, "
                f"wealth_path_probabilities={(self.wealth_path_probabilities
                     if hasattr(self, 'wealth_path_probabilities') else None)!s}, "
                f"last_reallocation_probability={(self.last_reallocation_probability
                     if hasattr(self, 'last_reallocation_probability') else None)!s}, "
                f"last_reallocation_date={(self.last_reallocation_date
                     if hasattr(self, 'last_reallocation_date') else None)!s}, "
                f"plan_id={(self.plan_id
                     if hasattr(self, 'plan_id') else None)!s}, "
                f"participant_id={(self.participant_id
                     if hasattr(self, 'participant_id') else None)!s}, "
                f"source_id={(self.source_id
                     if hasattr(self, 'source_id') else None)!s}, "
                f"use_age_based_cap={(self.use_age_based_cap
                     if hasattr(self, 'use_age_based_cap') else None)!s}, "
                f"inflation={(self.inflation
                     if hasattr(self, 'inflation') else None)!s}, "
                f"retirement_date={(self.retirement_date
                     if hasattr(self, 'retirement_date') else None)!s}, "
                f"target_portfolio={(self.target_portfolio
                     if hasattr(self, 'target_portfolio') else None)!s}, "
                f"mode={(self.mode if hasattr(self, 'mode') else None)!s}, "
                f"min_equity_allocation={(self.min_equity_allocation
                     if hasattr(self, 'min_equity_allocation') else None)!s}, "
                f"max_equity_allocation={(self.max_equity_allocation
                     if hasattr(self, 'max_equity_allocation') else None)!s}, "
                f"allocation_to_annuities={(self.allocation_to_annuities
                     if hasattr(self, 'allocation_to_annuities') else None)!s}, "
                f"additional_properties={self.additional_properties!s})")
