# -*- coding: utf-8 -*-

"""
greenbyteapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from greenbyteapi.api_helper import APIHelper
from greenbyteapi.models.metadata_field import MetadataField
from greenbyteapi.models.recurrence import Recurrence
from greenbyteapi.models.task_category import TaskCategory
from greenbyteapi.models.task_comment import TaskComment
from greenbyteapi.models.user import User


class Task(object):

    """Implementation of the 'Task' model.

    A task.

    Attributes:
        task_id (int): The id of a task.
        title (str): The model property of type str.
        created_by (User): The model property of type User.
        description (str): The model property of type str.
        category (TaskCategory): Basic information about a task category.
        priority (TaskPriorityEnum): The priority of a task.
        timestamp_start (datetime): The timestamp when the task is/was planned
            to start. The timestamp is in the time zone configured in the
            Greenbyte Platform without UTC offset.
        timestamp_end (datetime): The timestamp when the is/was planned to
            end. The timestamp is in the time zone configured in the Greenbyte
            Platform without UTC offset.
        state (TaskStateEnum): The state of a task.
        resolved (bool): The model property of type bool.
        timestamp_resolved (datetime): The timestamp when the task was
            resolved. The timestamp is in the time zone configured in the
            Greenbyte Platform without UTC offset.
        device_ids (List[int]): Ids of the devices assigned to the task.
        site_ids (List[int]): Ids of the sites assigned to the task.
        site_access_ids (List[int]): Ids of the site accesses linked to the
            task.
        downtime_event_ids (List[int]): Ids of the downtime events linked to
            the task.
        status_ids (List[int]): Ids of the statuses linked to the task.
        number_of_comments (int): The model property of type int.
        comments (List[TaskComment]): The comments belonging to the task.
        recurrence (Recurrence): Recurrence settings for the task. To
            calculate when the task is recurring, use the `timestampStart`
            field and then add to it multiples of the specified interval; the
            `intervalType` field determines if the task is recurring on daily,
            weekly, monthly, or yearly basis.  If the task is not recurring,
            this field is null.  **Note:** Only the main (first) task in a
            recurring series have recurrence settings. For the other tasks in
            the series, the field `mainTaskId` can be used to find it.
        main_task_id (int): The model property of type int.
        assignee (TaskAssigneeUser | TaskAssigneePersonnel |
            TaskAssigneeManufacturer | TaskAssigneeOther | None): The model
            property of type TaskAssigneeUser | TaskAssigneePersonnel |
            TaskAssigneeManufacturer | TaskAssigneeOther | None.
        metadata (List[MetadataField]): A list of metadata fields and their
            values.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "task_id": 'taskId',
        "title": 'title',
        "created_by": 'createdBy',
        "priority": 'priority',
        "timestamp_start": 'timestampStart',
        "timestamp_end": 'timestampEnd',
        "state": 'state',
        "resolved": 'resolved',
        "number_of_comments": 'numberOfComments',
        "description": 'description',
        "category": 'category',
        "timestamp_resolved": 'timestampResolved',
        "device_ids": 'deviceIds',
        "site_ids": 'siteIds',
        "site_access_ids": 'siteAccessIds',
        "downtime_event_ids": 'downtimeEventIds',
        "status_ids": 'statusIds',
        "comments": 'comments',
        "recurrence": 'recurrence',
        "main_task_id": 'mainTaskId',
        "assignee": 'assignee',
        "metadata": 'metadata'
    }

    _optionals = [
        'description',
        'category',
        'timestamp_resolved',
        'device_ids',
        'site_ids',
        'site_access_ids',
        'downtime_event_ids',
        'status_ids',
        'comments',
        'recurrence',
        'main_task_id',
        'assignee',
        'metadata',
    ]

    _nullables = [
        'description',
        'timestamp_resolved',
        'recurrence',
        'main_task_id',
        'assignee',
    ]

    def __init__(self,
                 task_id=None,
                 title=None,
                 created_by=None,
                 priority='medium',
                 timestamp_start=None,
                 timestamp_end=None,
                 state=None,
                 resolved=None,
                 number_of_comments=None,
                 description=APIHelper.SKIP,
                 category=APIHelper.SKIP,
                 timestamp_resolved=APIHelper.SKIP,
                 device_ids=APIHelper.SKIP,
                 site_ids=APIHelper.SKIP,
                 site_access_ids=APIHelper.SKIP,
                 downtime_event_ids=APIHelper.SKIP,
                 status_ids=APIHelper.SKIP,
                 comments=APIHelper.SKIP,
                 recurrence=APIHelper.SKIP,
                 main_task_id=APIHelper.SKIP,
                 assignee=APIHelper.SKIP,
                 metadata=APIHelper.SKIP):
        """Constructor for the Task class"""

        # Initialize members of the class
        self.task_id = task_id 
        self.title = title 
        self.created_by = created_by 
        if description is not APIHelper.SKIP:
            self.description = description 
        if category is not APIHelper.SKIP:
            self.category = category 
        self.priority = priority 
        self.timestamp_start = APIHelper.apply_datetime_converter(timestamp_start, APIHelper.RFC3339DateTime) if timestamp_start else None 
        self.timestamp_end = APIHelper.apply_datetime_converter(timestamp_end, APIHelper.RFC3339DateTime) if timestamp_end else None 
        self.state = state 
        self.resolved = resolved 
        if timestamp_resolved is not APIHelper.SKIP:
            self.timestamp_resolved = APIHelper.apply_datetime_converter(timestamp_resolved, APIHelper.RFC3339DateTime) if timestamp_resolved else None 
        if device_ids is not APIHelper.SKIP:
            self.device_ids = device_ids 
        if site_ids is not APIHelper.SKIP:
            self.site_ids = site_ids 
        if site_access_ids is not APIHelper.SKIP:
            self.site_access_ids = site_access_ids 
        if downtime_event_ids is not APIHelper.SKIP:
            self.downtime_event_ids = downtime_event_ids 
        if status_ids is not APIHelper.SKIP:
            self.status_ids = status_ids 
        self.number_of_comments = number_of_comments 
        if comments is not APIHelper.SKIP:
            self.comments = comments 
        if recurrence is not APIHelper.SKIP:
            self.recurrence = recurrence 
        if main_task_id is not APIHelper.SKIP:
            self.main_task_id = main_task_id 
        if assignee is not APIHelper.SKIP:
            self.assignee = assignee 
        if metadata is not APIHelper.SKIP:
            self.metadata = metadata 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        from greenbyteapi.utilities.union_type_lookup import UnionTypeLookUp

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        task_id = dictionary.get("taskId") if dictionary.get("taskId") else None
        title = dictionary.get("title") if dictionary.get("title") else None
        created_by = User.from_dictionary(dictionary.get('createdBy')) if dictionary.get('createdBy') else None
        priority = dictionary.get("priority") if dictionary.get("priority") else 'medium'
        timestamp_start = APIHelper.RFC3339DateTime.from_value(dictionary.get("timestampStart")).datetime if dictionary.get("timestampStart") else None
        timestamp_end = APIHelper.RFC3339DateTime.from_value(dictionary.get("timestampEnd")).datetime if dictionary.get("timestampEnd") else None
        state = dictionary.get("state") if dictionary.get("state") else None
        resolved = dictionary.get("resolved") if "resolved" in dictionary.keys() else None
        number_of_comments = dictionary.get("numberOfComments") if dictionary.get("numberOfComments") else None
        description = dictionary.get("description") if "description" in dictionary.keys() else APIHelper.SKIP
        category = TaskCategory.from_dictionary(dictionary.get('category')) if 'category' in dictionary.keys() else APIHelper.SKIP
        if 'timestampResolved' in dictionary.keys():
            timestamp_resolved = APIHelper.RFC3339DateTime.from_value(dictionary.get("timestampResolved")).datetime if dictionary.get("timestampResolved") else None
        else:
            timestamp_resolved = APIHelper.SKIP
        device_ids = dictionary.get("deviceIds") if dictionary.get("deviceIds") else APIHelper.SKIP
        site_ids = dictionary.get("siteIds") if dictionary.get("siteIds") else APIHelper.SKIP
        site_access_ids = dictionary.get("siteAccessIds") if dictionary.get("siteAccessIds") else APIHelper.SKIP
        downtime_event_ids = dictionary.get("downtimeEventIds") if dictionary.get("downtimeEventIds") else APIHelper.SKIP
        status_ids = dictionary.get("statusIds") if dictionary.get("statusIds") else APIHelper.SKIP
        comments = None
        if dictionary.get('comments') is not None:
            comments = [TaskComment.from_dictionary(x) for x in dictionary.get('comments')]
        else:
            comments = APIHelper.SKIP
        if 'recurrence' in dictionary.keys():
            recurrence = Recurrence.from_dictionary(dictionary.get('recurrence')) if dictionary.get('recurrence') else None
        else:
            recurrence = APIHelper.SKIP
        main_task_id = dictionary.get("mainTaskId") if "mainTaskId" in dictionary.keys() else APIHelper.SKIP
        if 'assignee' in dictionary.keys():
            assignee = APIHelper.deserialize_union_type(UnionTypeLookUp.get('TaskAssignee'), dictionary.get('assignee'), False) if dictionary.get('assignee') is not None else None
        else:
            assignee = APIHelper.SKIP
        metadata = None
        if dictionary.get('metadata') is not None:
            metadata = [MetadataField.from_dictionary(x) for x in dictionary.get('metadata')]
        else:
            metadata = APIHelper.SKIP
        # Return an object of this model
        return cls(task_id,
                   title,
                   created_by,
                   priority,
                   timestamp_start,
                   timestamp_end,
                   state,
                   resolved,
                   number_of_comments,
                   description,
                   category,
                   timestamp_resolved,
                   device_ids,
                   site_ids,
                   site_access_ids,
                   downtime_event_ids,
                   status_ids,
                   comments,
                   recurrence,
                   main_task_id,
                   assignee,
                   metadata)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'task_id={self.task_id!r}, '
                f'title={self.title!r}, '
                f'created_by={self.created_by!r}, '
                f'description={(self.description if hasattr(self, "description") else None)!r}, '
                f'category={(self.category if hasattr(self, "category") else None)!r}, '
                f'priority={self.priority!r}, '
                f'timestamp_start={self.timestamp_start!r}, '
                f'timestamp_end={self.timestamp_end!r}, '
                f'state={self.state!r}, '
                f'resolved={self.resolved!r}, '
                f'timestamp_resolved={(self.timestamp_resolved if hasattr(self, "timestamp_resolved") else None)!r}, '
                f'device_ids={(self.device_ids if hasattr(self, "device_ids") else None)!r}, '
                f'site_ids={(self.site_ids if hasattr(self, "site_ids") else None)!r}, '
                f'site_access_ids={(self.site_access_ids if hasattr(self, "site_access_ids") else None)!r}, '
                f'downtime_event_ids={(self.downtime_event_ids if hasattr(self, "downtime_event_ids") else None)!r}, '
                f'status_ids={(self.status_ids if hasattr(self, "status_ids") else None)!r}, '
                f'number_of_comments={self.number_of_comments!r}, '
                f'comments={(self.comments if hasattr(self, "comments") else None)!r}, '
                f'recurrence={(self.recurrence if hasattr(self, "recurrence") else None)!r}, '
                f'main_task_id={(self.main_task_id if hasattr(self, "main_task_id") else None)!r}, '
                f'assignee={(self.assignee if hasattr(self, "assignee") else None)!r}, '
                f'metadata={(self.metadata if hasattr(self, "metadata") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'task_id={self.task_id!s}, '
                f'title={self.title!s}, '
                f'created_by={self.created_by!s}, '
                f'description={(self.description if hasattr(self, "description") else None)!s}, '
                f'category={(self.category if hasattr(self, "category") else None)!s}, '
                f'priority={self.priority!s}, '
                f'timestamp_start={self.timestamp_start!s}, '
                f'timestamp_end={self.timestamp_end!s}, '
                f'state={self.state!s}, '
                f'resolved={self.resolved!s}, '
                f'timestamp_resolved={(self.timestamp_resolved if hasattr(self, "timestamp_resolved") else None)!s}, '
                f'device_ids={(self.device_ids if hasattr(self, "device_ids") else None)!s}, '
                f'site_ids={(self.site_ids if hasattr(self, "site_ids") else None)!s}, '
                f'site_access_ids={(self.site_access_ids if hasattr(self, "site_access_ids") else None)!s}, '
                f'downtime_event_ids={(self.downtime_event_ids if hasattr(self, "downtime_event_ids") else None)!s}, '
                f'status_ids={(self.status_ids if hasattr(self, "status_ids") else None)!s}, '
                f'number_of_comments={self.number_of_comments!s}, '
                f'comments={(self.comments if hasattr(self, "comments") else None)!s}, '
                f'recurrence={(self.recurrence if hasattr(self, "recurrence") else None)!s}, '
                f'main_task_id={(self.main_task_id if hasattr(self, "main_task_id") else None)!s}, '
                f'assignee={(self.assignee if hasattr(self, "assignee") else None)!s}, '
                f'metadata={(self.metadata if hasattr(self, "metadata") else None)!s})')
