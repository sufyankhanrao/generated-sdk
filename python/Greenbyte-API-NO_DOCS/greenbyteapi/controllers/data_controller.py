# -*- coding: utf-8 -*-

"""
greenbyteapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""

from greenbyteapi.api_helper import APIHelper
from greenbyteapi.configuration import Server
from greenbyteapi.http.api_response import ApiResponse
from greenbyteapi.controllers.base_controller import BaseController
from apimatic_core.request_builder import RequestBuilder
from apimatic_core.response_handler import ResponseHandler
from apimatic_core.types.parameter import Parameter
from greenbyteapi.http.http_method_enum import HttpMethodEnum
from apimatic_core.types.array_serialization_format import SerializationFormats
from apimatic_core.authentication.multiple.single_auth import Single
from greenbyteapi.models.data_signal_item import DataSignalItem
from greenbyteapi.models.data_item import DataItem
from greenbyteapi.models.data_real_time_item import DataRealTimeItem
from greenbyteapi.models.data_per_category_response import DataPerCategoryResponse
from greenbyteapi.models.highresdata_response import HighresdataResponse
from greenbyteapi.exceptions.problem_details_exception import ProblemDetailsException
from greenbyteapi.exceptions.api_exception import APIException


class DataController(BaseController):

    """A Controller to access Endpoints in the greenbyteapi API."""
    def __init__(self, config):
        super(DataController, self).__init__(config)

    def get_data_signals(self,
                         device_ids=None):
        """Does a GET request to /datasignals.

        Gets authorized data signals for one or more devices.
        _üîê This endpoint requires the **Data** endpoint permission._
        _This request can also be made using the POST method, 
        with a request to `datasignals.json` and 
        a JSON request body instead of query parameters._

        Args:
            device_ids (List[int], optional): What devices to get data signals
                for.

        Returns:
            ApiResponse: An object with the response value as well as other
                useful information such as status codes and headers. The data
                signals available for one or several of the devices.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path('/datasignals')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('deviceIds')
                         .value(device_ids))
            .header_param(Parameter()
                          .key('accept')
                          .value('application/json'))
            .array_serialization_format(SerializationFormats.CSV)
            .auth(Single('ApiKeyHeaderAuth'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(DataSignalItem.from_dictionary)
            .is_api_response(True)
            .local_error('400', 'The request cannot be fulfilled due to bad syntax.', ProblemDetailsException)
            .local_error('401', 'The request is missing a valid API key.\n', APIException)
            .local_error('403', 'One of the following:\n* The API key does not authorize access to the requested endpoint because of a missing endpoint permission.\n* The API key does not authorize access to the requested data. Devices, sites or data signals can be limited.\n', APIException)
            .local_error('405', 'The HTTP method is not allowed for the endpoint.', APIException)
            .local_error('429', 'The API key has been used in too many requests in a given amount\nof time. The following headers will be set in the response:\n* `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example\n  "1m", "12h", or "1d").\n* `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests\n  for this period.\n* `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601\n  format) when the remaining number of requests resets.\n\nThe limit is currently 1,000 requests/minute per API key and IP\naddress.\n', ProblemDetailsException)
        ).execute()

    def get_data(self,
                 device_ids,
                 data_signal_ids,
                 timestamp_start,
                 timestamp_end,
                 use_utc=False,
                 resolution='10minute',
                 aggregate='device',
                 aggregate_level=0,
                 calculation=None):
        """Does a GET request to /data.

        Gets data for multiple devices and data signals in the given
        resolution. The timestamps are in the time zone configured in the
        Greenbyte Platform.
        Use the useUtc flag to get timestamps in UTC for all resolutions other
        than daily, weekly, monthly and yearly.
        _üîê This endpoint requires the **Data** endpoint permission._
        _This request can also be made using the POST method, 
        with a request to `data.json` and 
        a JSON request body instead of query parameters._

        Args:
            device_ids (List[int]): Which devices to get data for.
            data_signal_ids (List[int]): Which data signals to get data for.
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            use_utc (bool, optional): Set to true to get timestamps in UTC.
                UTC timestamps are available for all resolutions other than
                daily, weekly, monthly and yearly.
            resolution (ResolutionEnum, optional): The desired data resolution.
            aggregate (AggregateModeEnum, optional): How the data should be
                aggregated with regards to device(s) or site(s).
            aggregate_level (int, optional): When AggregateMode `siteLevel` is
                used this parameter controls down to which level in the
                hierarchy to aggregate.
            calculation (CalculationModeEnum, optional): The calculation used
                when aggregating data, both over time and across devices. The
                default is the data signal default.

        Returns:
            ApiResponse: An object with the response value as well as other
                useful information such as status codes and headers. The data
                grouped by data signal and aggregate.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path('/data')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('deviceIds')
                         .value(device_ids))
            .query_param(Parameter()
                         .key('dataSignalIds')
                         .value(data_signal_ids))
            .query_param(Parameter()
                         .key('timestampStart')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start)))
            .query_param(Parameter()
                         .key('timestampEnd')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end)))
            .query_param(Parameter()
                         .key('useUtc')
                         .value(use_utc))
            .query_param(Parameter()
                         .key('resolution')
                         .value(resolution))
            .query_param(Parameter()
                         .key('aggregate')
                         .value(aggregate))
            .query_param(Parameter()
                         .key('aggregateLevel')
                         .value(aggregate_level))
            .query_param(Parameter()
                         .key('calculation')
                         .value(calculation))
            .header_param(Parameter()
                          .key('accept')
                          .value('application/json'))
            .array_serialization_format(SerializationFormats.CSV)
            .auth(Single('ApiKeyHeaderAuth'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(DataItem.from_dictionary)
            .is_api_response(True)
            .local_error('400', 'The request cannot be fulfilled due to bad syntax.', ProblemDetailsException)
            .local_error('401', 'The request is missing a valid API key.\n', APIException)
            .local_error('403', 'One of the following:\n* The API key does not authorize access to the requested endpoint because of a missing endpoint permission.\n* The API key does not authorize access to the requested data. Devices, sites or data signals can be limited.\n', APIException)
            .local_error('405', 'The HTTP method is not allowed for the endpoint.', APIException)
            .local_error('429', 'The API key has been used in too many requests in a given amount\nof time. The following headers will be set in the response:\n* `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example\n  "1m", "12h", or "1d").\n* `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests\n  for this period.\n* `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601\n  format) when the remaining number of requests resets.\n\nThe limit is currently 1,000 requests/minute per API key and IP\naddress.\n', ProblemDetailsException)
        ).execute()

    def get_real_time_data(self,
                           device_ids,
                           data_signal_ids,
                           aggregate='device',
                           aggregate_level=0,
                           calculation=None):
        """Does a GET request to /realtimedata.

        Gets the most recent data point for each
        specified device and data signal. The timestamps are in UTC.
        _üîê This endpoint requires the **Data** endpoint permission._
        _This request can also be made using the POST method, 
        with a request to `realtimedata.json` and 
        a JSON request body instead of query parameters._

        Args:
            device_ids (List[int]): Which devices to get data for.
            data_signal_ids (List[int]): Which data signals to get data for.
            aggregate (AggregateModeEnum, optional): How the data should be
                aggregated with regards to device(s) or site(s).
            aggregate_level (int, optional): When AggregateMode `siteLevel` is
                used this parameter controls down to which level in the
                hierarchy to aggregate.
            calculation (CalculationModeRealTimeEnum, optional): The
                calculation used when aggregating data, both over time and
                across devices. The default is the data signal default.

        Returns:
            ApiResponse: An object with the response value as well as other
                useful information such as status codes and headers. The most
                recent data points grouped by data signal and aggregate.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path('/realtimedata')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('deviceIds')
                         .value(device_ids))
            .query_param(Parameter()
                         .key('dataSignalIds')
                         .value(data_signal_ids))
            .query_param(Parameter()
                         .key('aggregate')
                         .value(aggregate))
            .query_param(Parameter()
                         .key('aggregateLevel')
                         .value(aggregate_level))
            .query_param(Parameter()
                         .key('calculation')
                         .value(calculation))
            .header_param(Parameter()
                          .key('accept')
                          .value('application/json'))
            .array_serialization_format(SerializationFormats.CSV)
            .auth(Single('ApiKeyHeaderAuth'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(DataRealTimeItem.from_dictionary)
            .is_api_response(True)
            .local_error('400', 'The request cannot be fulfilled due to bad syntax.', ProblemDetailsException)
            .local_error('401', 'The request is missing a valid API key.\n', APIException)
            .local_error('403', 'One of the following:\n* The API key does not authorize access to the requested endpoint because of a missing endpoint permission.\n* The API key does not authorize access to the requested data. Devices, sites or data signals can be limited.\n', APIException)
            .local_error('405', 'The HTTP method is not allowed for the endpoint.', APIException)
            .local_error('429', 'The API key has been used in too many requests in a given amount\nof time. The following headers will be set in the response:\n* `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example\n  "1m", "12h", or "1d").\n* `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests\n  for this period.\n* `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601\n  format) when the remaining number of requests resets.\n\nThe limit is currently 1,000 requests/minute per API key and IP\naddress.\n', ProblemDetailsException)
        ).execute()

    def get_data_per_category(self,
                              device_ids,
                              data_signal_id,
                              timestamp_start,
                              timestamp_end,
                              aggregate='device',
                              aggregate_level=0,
                              category=None,
                              contract_type='service'):
        """Does a GET request to /datapercategory.

        Gets signal data aggregated per availability contract category.
        _üîê This endpoint requires the **Data** and **Statuses** endpoint
        permissions._
        _This request can also be made using the POST method, 
        with a request to `datapercategory.json` and 
        a JSON request body instead of query parameters._

        Args:
            device_ids (List[int]): Which devices to get data for.
            data_signal_id (int): Which signal to get data for; only Lost
                Production signals are supported at the moment.
            timestamp_start (datetime): The beginning of the time interval to
                get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime): The end of the time interval to get data
                for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            aggregate (AggregateModeEnum, optional): How the data should be
                aggregated with regards to device(s) or site(s).
            aggregate_level (int, optional): When AggregateMode `siteLevel` is
                used this parameter controls down to which level in the
                hierarchy to aggregate.
            category (List[StatusCategoryEnum], optional): Which status
                categories to include. By default all categories are included.
            contract_type (ContractTypeEnum, optional): Which contract type to
                use if using multiple availability contracts.

        Returns:
            ApiResponse: An object with the response value as well as other
                useful information such as status codes and headers. The data
                grouped by aggregate (device, site, etc.) and contract
                category.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path('/datapercategory')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('deviceIds')
                         .value(device_ids))
            .query_param(Parameter()
                         .key('dataSignalId')
                         .value(data_signal_id))
            .query_param(Parameter()
                         .key('timestampStart')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start)))
            .query_param(Parameter()
                         .key('timestampEnd')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end)))
            .query_param(Parameter()
                         .key('aggregate')
                         .value(aggregate))
            .query_param(Parameter()
                         .key('aggregateLevel')
                         .value(aggregate_level))
            .query_param(Parameter()
                         .key('category')
                         .value(category))
            .query_param(Parameter()
                         .key('contractType')
                         .value(contract_type))
            .header_param(Parameter()
                          .key('accept')
                          .value('application/json'))
            .array_serialization_format(SerializationFormats.CSV)
            .auth(Single('ApiKeyHeaderAuth'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(DataPerCategoryResponse.from_dictionary)
            .is_api_response(True)
            .local_error('400', 'The request cannot be fulfilled due to bad syntax.', ProblemDetailsException)
            .local_error('401', 'The request is missing a valid API key.\n', APIException)
            .local_error('403', 'One of the following:\n* The API key does not authorize access to the requested endpoint because of a missing endpoint permission.\n* The API key does not authorize access to the requested data. Devices, sites or data signals can be limited.\n', APIException)
            .local_error('405', 'The HTTP method is not allowed for the endpoint.', APIException)
            .local_error('429', 'The API key has been used in too many requests in a given amount\nof time. The following headers will be set in the response:\n* `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example\n  "1m", "12h", or "1d").\n* `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests\n  for this period.\n* `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601\n  format) when the remaining number of requests resets.\n\nThe limit is currently 1,000 requests/minute per API key and IP\naddress.\n', ProblemDetailsException)
        ).execute()

    def get_high_res_data(self,
                          device_ids,
                          data_signal_id,
                          timestamp_start=None,
                          timestamp_end=None):
        """Does a GET request to /highresdata.

        Gets high resolution data for a data signal for each
        specified device. The timestamps are in UTC.
        The endpoint returns up to an hour's worth of high resolution data for
        the provided device IDs and data signal ID.
        It is possible to request data for up to 10 separate devices and one
        data signal ID.
        Timestamp start and end are optional. The default time span returned
        is the latest hour.
        If supplied, timestamp start must be within the past 12 hours.
        Timestamp end will by default be an hour after timestamp start but can
        be set for shorter intervals.
        There is no high resolution data available for data signals that are
        calculated. 
        The data for those signals can be retrieved through the data endpoint.
        _üîê This endpoint requires the **HighResolution** endpoint permission._

        Args:
            device_ids (List[int]): Which devices to get data for.
            data_signal_id (int): Which data signal to get data for.
            timestamp_start (datetime, optional): The beginning of the time
                interval to get data for (inclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                start timestamp **is** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.
            timestamp_end (datetime, optional): The end of the time interval
                to get data for (exclusive), in [RFC 3339, section
                5.6](https://tools.ietf.org/html/rfc3339#section-5.6)
                **date-time** format:  * Timestamps ending with 'Z' are
                treated as UTC. Example: "2020-01-01T00:00:00Z" * Time zone
                (UTC) offset timestamps ending with '+HH:mm'/"-HH:mm" are also
                supported. Example: "2020-01-01T02:00:00-02:00" * Other
                timestamps are treated as being in the time zone configured in
                the Greenbyte Platform. Example: "2020-01-01T00:00:00"  The
                end timestamp is **not** included in the time interval: for
                example, to select the full month of March 2020, set
                `timestampStart` to "2020-03-01T00:00:00" and `timestampEnd`
                to "2020-04-01T00:00:00".  Timestamps selected in the portal
                will by default be in UTC.

        Returns:
            ApiResponse: An object with the response value as well as other
                useful information such as status codes and headers. High
                resolution data from different devices for a certain data
                signal.

        Raises:
            APIException: When an error occurs while fetching the data from
                the remote API. This exception includes the HTTP Response
                code, an error message, and the HTTP body that was received in
                the request.

        """

        return super().new_api_call_builder.request(
            RequestBuilder().server(Server.DEFAULT)
            .path('/highresdata')
            .http_method(HttpMethodEnum.GET)
            .query_param(Parameter()
                         .key('deviceIds')
                         .value(device_ids))
            .query_param(Parameter()
                         .key('dataSignalId')
                         .value(data_signal_id))
            .query_param(Parameter()
                         .key('timestampStart')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_start)))
            .query_param(Parameter()
                         .key('timestampEnd')
                         .value(APIHelper.when_defined(APIHelper.RFC3339DateTime, timestamp_end)))
            .header_param(Parameter()
                          .key('accept')
                          .value('application/json'))
            .array_serialization_format(SerializationFormats.CSV)
            .auth(Single('ApiKeyHeaderAuth'))
        ).response(
            ResponseHandler()
            .deserializer(APIHelper.json_deserialize)
            .deserialize_into(HighresdataResponse.from_dictionary)
            .is_api_response(True)
            .local_error('400', 'The request cannot be fulfilled due to bad syntax.', ProblemDetailsException)
            .local_error('401', 'The request is missing a valid API key.\n', APIException)
            .local_error('403', 'One of the following:\n* The API key does not authorize access to the requested endpoint because of a missing endpoint permission.\n* The API key does not authorize access to the requested data. Devices, sites or data signals can be limited.\n', APIException)
            .local_error('405', 'The HTTP method is not allowed for the endpoint.', APIException)
            .local_error('429', 'The API key has been used in too many requests in a given amount\nof time. The following headers will be set in the response:\n* `X-Rate-Limit-Limit` ‚Äì The rate limit period (for example\n  "1m", "12h", or "1d").\n* `X-Rate-Limit-Remaining` ‚Äì The remaining number of requests\n  for this period.\n* `X-Rate-Limit-Reset` ‚Äì The UTC timestamp string (in ISO 8601\n  format) when the remaining number of requests resets.\n\nThe limit is currently 1,000 requests/minute per API key and IP\naddress.\n', ProblemDetailsException)
        ).execute()
