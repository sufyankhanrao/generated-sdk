"""payrix.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from payrix.api_helper import APIHelper


class SubscriptionsResponse(object):
    """Implementation of the 'subscriptionsResponse' model.

    Attributes:
        id (str): The ID of this resource.
        created (str): The date and time at which this resource was created.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        modified (str): The date and time at which this resource was modified.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        creator (str | LoginsResponse | None): The model property of type str
            | LoginsResponse | None.
        modifier (str): The identifier of the Login that last modified this
            resource.
        plan (str): The identifier of the Plan that this Subscription is
            associated with. The Plan determines the frequency and amount of
            each payment.
        statement_entity (str): For a plan that is attached to a billing, this
            is the paying entity to match to the generated statements of that
            billing for which the recurring payments will be made.
        first_txn (str): The identification of the first transaction processed
            through this subscription. This is used internally to process
            subsequent transactions.
        start (int): The date on which the Subscription should start. The date
            is specified as an eight digit string in YYYYMMDD format, for
            example, '20160120' for January 20, 2016. The value of this field
            must represent a date in the future.
        finish (int): The date on which the Subscription should finish. The
            date is specified as an eight digit string in YYYYMMDD format, for
            example, '20160120' for January 20, 2016. The value of this field
            must represent a date in the future.
        tax (int): The amount of the total sum of this Subscription that is
            made up of tax. This field is specified as an integer in cents.
        descriptor (str): The descriptor used in this Subscription. This field
            is stored as a text string and must be between 1 and 50 characters
            long. If a value is not set, an attempt is made to set a default
            value from the merchant information.
        txn_description (str): The description of the Txn that will be created
            through this Subscription.
        order (str): The order of the Txn that will be created through this
            Subscription.
        origin (SubscriptionOriginEnum): The origin of the Txn that will be
            created through this Subscription.  <details> <summary>Valid
            Values</summary>  - `2` - **Customer will be subscribing through
            eCommerce.** - `3` - **Customer will be subscribing by Mail
            Order/Telephone.** - `4` - **Originated with Apple Pay.** - `5` -
            **Originated as a Successful 3D Secure transaction.** - `6` -
            **Originated as an Attempted 3D Secure transaction.** - `8` -
            **Originated in a Payframe.**  </details>
        authentication (str): Authentication token for 3D Secure transactions.
        authentication_id (str): Authentication reference ID for 3D Secure
            transactions.
        failures (int): The current count of consecutive payment failures for
            this subscription.
        max_failures (int): The maximum consecutive amount of payment failures
            to allow for this subscription before inactivating it.
        inactive (InactiveEnum): Whether this resource is marked as inactive.
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen.
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "id": "id",
        "created": "created",
        "modified": "modified",
        "creator": "creator",
        "modifier": "modifier",
        "plan": "plan",
        "statement_entity": "statementEntity",
        "first_txn": "firstTxn",
        "start": "start",
        "finish": "finish",
        "tax": "tax",
        "descriptor": "descriptor",
        "txn_description": "txnDescription",
        "order": "order",
        "origin": "origin",
        "authentication": "authentication",
        "authentication_id": "authenticationId",
        "failures": "failures",
        "max_failures": "maxFailures",
        "inactive": "inactive",
        "frozen": "frozen",
    }

    _optionals = [
        "id",
        "created",
        "modified",
        "creator",
        "modifier",
        "plan",
        "statement_entity",
        "first_txn",
        "start",
        "finish",
        "tax",
        "descriptor",
        "txn_description",
        "order",
        "origin",
        "authentication",
        "authentication_id",
        "failures",
        "max_failures",
        "inactive",
        "frozen",
    ]

    def __init__(self,
                 id=APIHelper.SKIP,
                 created=APIHelper.SKIP,
                 modified=APIHelper.SKIP,
                 creator=APIHelper.SKIP,
                 modifier=APIHelper.SKIP,
                 plan=APIHelper.SKIP,
                 statement_entity=APIHelper.SKIP,
                 first_txn=APIHelper.SKIP,
                 start=APIHelper.SKIP,
                 finish=APIHelper.SKIP,
                 tax=APIHelper.SKIP,
                 descriptor=APIHelper.SKIP,
                 txn_description=APIHelper.SKIP,
                 order=APIHelper.SKIP,
                 origin=2,
                 authentication=APIHelper.SKIP,
                 authentication_id=APIHelper.SKIP,
                 failures=APIHelper.SKIP,
                 max_failures=APIHelper.SKIP,
                 inactive=0,
                 frozen=0):
        """Initialize a SubscriptionsResponse instance."""
        # Initialize members of the class
        if id is not APIHelper.SKIP:
            self.id = id
        if created is not APIHelper.SKIP:
            self.created = created
        if modified is not APIHelper.SKIP:
            self.modified = modified
        if creator is not APIHelper.SKIP:
            self.creator = creator
        if modifier is not APIHelper.SKIP:
            self.modifier = modifier
        if plan is not APIHelper.SKIP:
            self.plan = plan
        if statement_entity is not APIHelper.SKIP:
            self.statement_entity = statement_entity
        if first_txn is not APIHelper.SKIP:
            self.first_txn = first_txn
        if start is not APIHelper.SKIP:
            self.start = start
        if finish is not APIHelper.SKIP:
            self.finish = finish
        if tax is not APIHelper.SKIP:
            self.tax = tax
        if descriptor is not APIHelper.SKIP:
            self.descriptor = descriptor
        if txn_description is not APIHelper.SKIP:
            self.txn_description = txn_description
        if order is not APIHelper.SKIP:
            self.order = order
        self.origin = origin
        if authentication is not APIHelper.SKIP:
            self.authentication = authentication
        if authentication_id is not APIHelper.SKIP:
            self.authentication_id = authentication_id
        if failures is not APIHelper.SKIP:
            self.failures = failures
        if max_failures is not APIHelper.SKIP:
            self.max_failures = max_failures
        self.inactive = inactive
        self.frozen = frozen

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        from payrix.utilities.union_type_lookup import (
            UnionTypeLookUp,
        )

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        id = dictionary.get("id") if dictionary.get("id") else APIHelper.SKIP
        created =\
            dictionary.get("created")\
            if dictionary.get("created") else APIHelper.SKIP
        modified =\
            dictionary.get("modified")\
            if dictionary.get("modified") else APIHelper.SKIP
        creator = APIHelper.deserialize_union_type(UnionTypeLookUp.get("SubscriptionsResponseCreator"), dictionary.get("creator"), False) if dictionary.get("creator") is not None else APIHelper.SKIP
        modifier =\
            dictionary.get("modifier")\
            if dictionary.get("modifier") else APIHelper.SKIP
        plan =\
            dictionary.get("plan")\
            if dictionary.get("plan") else APIHelper.SKIP
        statement_entity =\
            dictionary.get("statementEntity")\
            if dictionary.get("statementEntity") else APIHelper.SKIP
        first_txn =\
            dictionary.get("firstTxn")\
            if dictionary.get("firstTxn") else APIHelper.SKIP
        start =\
            dictionary.get("start")\
            if dictionary.get("start") else APIHelper.SKIP
        finish =\
            dictionary.get("finish")\
            if dictionary.get("finish") else APIHelper.SKIP
        tax = dictionary.get("tax") if dictionary.get("tax") else APIHelper.SKIP
        descriptor =\
            dictionary.get("descriptor")\
            if dictionary.get("descriptor") else APIHelper.SKIP
        txn_description =\
            dictionary.get("txnDescription")\
            if dictionary.get("txnDescription") else APIHelper.SKIP
        order =\
            dictionary.get("order")\
            if dictionary.get("order") else APIHelper.SKIP
        origin = dictionary.get("origin") if dictionary.get("origin") else 2
        authentication =\
            dictionary.get("authentication")\
            if dictionary.get("authentication") else APIHelper.SKIP
        authentication_id =\
            dictionary.get("authenticationId")\
            if dictionary.get("authenticationId") else APIHelper.SKIP
        failures =\
            dictionary.get("failures")\
            if dictionary.get("failures") else APIHelper.SKIP
        max_failures =\
            dictionary.get("maxFailures")\
            if dictionary.get("maxFailures") else APIHelper.SKIP
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        # Return an object of this model
        return cls(id,
                   created,
                   modified,
                   creator,
                   modifier,
                   plan,
                   statement_entity,
                   first_txn,
                   start,
                   finish,
                   tax,
                   descriptor,
                   txn_description,
                   order,
                   origin,
                   authentication,
                   authentication_id,
                   failures,
                   max_failures,
                   inactive,
                   frozen)

    @classmethod
    def validate(cls, dictionary):
        """Validate dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """
        if isinstance(dictionary, cls):
            return True

        if not isinstance(dictionary, dict):
            return False

        return True

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"id={(self.id if hasattr(self, 'id') else None)!r}, "
                f"created={(self.created
                     if hasattr(self, 'created') else None)!r}, "
                f"modified={(self.modified
                     if hasattr(self, 'modified') else None)!r}, "
                f"creator={(self.creator
                     if hasattr(self, 'creator') else None)!r}, "
                f"modifier={(self.modifier
                     if hasattr(self, 'modifier') else None)!r}, "
                f"plan={(self.plan if hasattr(self, 'plan') else None)!r}, "
                f"statement_entity={(self.statement_entity
                     if hasattr(self, 'statement_entity') else None)!r}, "
                f"first_txn={(self.first_txn
                     if hasattr(self, 'first_txn') else None)!r}, "
                f"start={(self.start if hasattr(self, 'start') else None)!r}, "
                f"finish={(self.finish if hasattr(self, 'finish') else None)!r}, "
                f"tax={(self.tax if hasattr(self, 'tax') else None)!r}, "
                f"descriptor={(self.descriptor
                     if hasattr(self, 'descriptor') else None)!r}, "
                f"txn_description={(self.txn_description
                     if hasattr(self, 'txn_description') else None)!r}, "
                f"order={(self.order if hasattr(self, 'order') else None)!r}, "
                f"origin={(self.origin if hasattr(self, 'origin') else None)!r}, "
                f"authentication={(self.authentication
                     if hasattr(self, 'authentication') else None)!r}, "
                f"authentication_id={(self.authentication_id
                     if hasattr(self, 'authentication_id') else None)!r}, "
                f"failures={(self.failures
                     if hasattr(self, 'failures') else None)!r}, "
                f"max_failures={(self.max_failures
                     if hasattr(self, 'max_failures') else None)!r}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!r}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"id={(self.id if hasattr(self, 'id') else None)!s}, "
                f"created={(self.created
                     if hasattr(self, 'created') else None)!s}, "
                f"modified={(self.modified
                     if hasattr(self, 'modified') else None)!s}, "
                f"creator={(self.creator
                     if hasattr(self, 'creator') else None)!s}, "
                f"modifier={(self.modifier
                     if hasattr(self, 'modifier') else None)!s}, "
                f"plan={(self.plan if hasattr(self, 'plan') else None)!s}, "
                f"statement_entity={(self.statement_entity
                     if hasattr(self, 'statement_entity') else None)!s}, "
                f"first_txn={(self.first_txn
                     if hasattr(self, 'first_txn') else None)!s}, "
                f"start={(self.start if hasattr(self, 'start') else None)!s}, "
                f"finish={(self.finish if hasattr(self, 'finish') else None)!s}, "
                f"tax={(self.tax if hasattr(self, 'tax') else None)!s}, "
                f"descriptor={(self.descriptor
                     if hasattr(self, 'descriptor') else None)!s}, "
                f"txn_description={(self.txn_description
                     if hasattr(self, 'txn_description') else None)!s}, "
                f"order={(self.order if hasattr(self, 'order') else None)!s}, "
                f"origin={(self.origin if hasattr(self, 'origin') else None)!s}, "
                f"authentication={(self.authentication
                     if hasattr(self, 'authentication') else None)!s}, "
                f"authentication_id={(self.authentication_id
                     if hasattr(self, 'authentication_id') else None)!s}, "
                f"failures={(self.failures
                     if hasattr(self, 'failures') else None)!s}, "
                f"max_failures={(self.max_failures
                     if hasattr(self, 'max_failures') else None)!s}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!s}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!s})")
