# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper
from payrix.models.billing_schedule_enum import BillingScheduleEnum
from payrix.models.collection_factor_enum import CollectionFactorEnum
from payrix.models.collection_include_current_enum import CollectionIncludeCurrentEnum
from payrix.models.currency_enum import CurrencyEnum
from payrix.models.frozen_enum import FrozenEnum
from payrix.models.inactive_enum import InactiveEnum


class BillingsPostRequest(object):

    """Implementation of the 'billingsPostRequest' model.

    Attributes:
        login (str): The Login that owns this resource.
        entity (str): The alphanumeric identifier of the Entity associated
            with this Account.
        forentity (str): The alphanumeric identifier of the Entity associated
            with this Account.
        org (str): The identifier of the Org associated with this
            invoiceParameter.
        division (str): ID of the division associated with this vendor
        partition (str): The identifier of the Partition associated with this
            invoiceParameter.
        description (str): The billing details.
        schedule (BillingScheduleEnum): The schedule that determines when this
            Billing is triggered to start collecting data.  <details>
            <summary>Valid Values</summary>  - `days` - **Daily schedule.** -
            `weeks` - **Weekly schedule.** - `months` - **Monthly schedule.**
            - `years` - **Annual schedule.**  </details>
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, if it is set to a
            duration-based trigger, such as daily, weekly, monthly, or
            annually.  This field is specified as an integer and its value
            determines how the interval is multiplied.
        start (int): The date on which this Billing period should start.
        finish (int): The date on which this Billing period should end.
        collection (str): Determines who will be billed.  <details>
            <summary>Valid Values</summary>  - `entity` - **The entity will be
            billed.**  </details>
        collection_factor (CollectionFactorEnum): A multiplier that you can
            use to adjust the set of data to be used in the collection
            calculation.  <details> <summary>Valid Values</summary>  - `days`
            - **Days.** Multiplier based on days. - `weeks` - **Weeks.**
            Multiplier based on weeks. - `months` - **Months.** Multiplier
            based on months. - `years` - **Years.** Multiplier based on years.
            </details>
        collection_offset (int): The number of days, weeks, months or years to
            go back when selecting data for collection calculation.
        collection_include_current (CollectionIncludeCurrentEnum): Whether to
            include the current period in the collection calculation. 
            <details> <summary>Valid Values</summary>  - `0` - **Exclude
            Current Period.** Do not include the current period in the
            calculation. - `1` - **Include Current Period.** Include the
            current period in the calculation.  </details>
        currency (CurrencyEnum): The currency of the amount in this billing.
            See <a href="https://www.iban.com/currency-codes"
            target="_blank">Currency codes</a>  for all valid values.
        inactive (InactiveEnum): Whether this resource is marked as inactive. 
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen. 
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "login": 'login',
        "entity": 'entity',
        "schedule": 'schedule',
        "schedule_factor": 'scheduleFactor',
        "start": 'start',
        "collection": 'collection',
        "collection_factor": 'collectionFactor',
        "collection_offset": 'collectionOffset',
        "collection_include_current": 'collectionIncludeCurrent',
        "currency": 'currency',
        "inactive": 'inactive',
        "frozen": 'frozen',
        "forentity": 'forentity',
        "org": 'org',
        "division": 'division',
        "partition": 'partition',
        "description": 'description',
        "finish": 'finish'
    }

    _optionals = [
        'forentity',
        'org',
        'division',
        'partition',
        'description',
        'finish',
    ]

    _nullables = [
        'currency',
    ]

    def __init__(self,
                 login=None,
                 entity=None,
                 schedule=None,
                 schedule_factor=1,
                 start=None,
                 collection_factor=None,
                 collection_offset=1,
                 collection_include_current=0,
                 currency=None,
                 inactive=0,
                 frozen=0,
                 forentity=APIHelper.SKIP,
                 org=APIHelper.SKIP,
                 division=APIHelper.SKIP,
                 partition=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 finish=APIHelper.SKIP):
        """Constructor for the BillingsPostRequest class"""

        # Initialize members of the class
        self.login = login 
        self.entity = entity 
        if forentity is not APIHelper.SKIP:
            self.forentity = forentity 
        if org is not APIHelper.SKIP:
            self.org = org 
        if division is not APIHelper.SKIP:
            self.division = division 
        if partition is not APIHelper.SKIP:
            self.partition = partition 
        if description is not APIHelper.SKIP:
            self.description = description 
        self.schedule = schedule 
        self.schedule_factor = schedule_factor 
        self.start = start 
        if finish is not APIHelper.SKIP:
            self.finish = finish 
        self.collection = 'entity' 
        self.collection_factor = collection_factor 
        self.collection_offset = collection_offset 
        self.collection_include_current = collection_include_current 
        self.currency = currency 
        self.inactive = inactive 
        self.frozen = frozen 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        login = dictionary.get("login") if dictionary.get("login") else None
        entity = dictionary.get("entity") if dictionary.get("entity") else None
        schedule = dictionary.get("schedule") if dictionary.get("schedule") else None
        schedule_factor = dictionary.get("scheduleFactor") if dictionary.get("scheduleFactor") else 1
        start = dictionary.get("start") if dictionary.get("start") else None
        collection_factor = dictionary.get("collectionFactor") if dictionary.get("collectionFactor") else None
        collection_offset = dictionary.get("collectionOffset") if dictionary.get("collectionOffset") else 1
        collection_include_current = dictionary.get("collectionIncludeCurrent") if dictionary.get("collectionIncludeCurrent") else 0
        currency = dictionary.get("currency") if dictionary.get("currency") else None
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        forentity = dictionary.get("forentity") if dictionary.get("forentity") else APIHelper.SKIP
        org = dictionary.get("org") if dictionary.get("org") else APIHelper.SKIP
        division = dictionary.get("division") if dictionary.get("division") else APIHelper.SKIP
        partition = dictionary.get("partition") if dictionary.get("partition") else APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        finish = dictionary.get("finish") if dictionary.get("finish") else APIHelper.SKIP
        # Return an object of this model
        return cls(login,
                   entity,
                   schedule,
                   schedule_factor,
                   start,
                   collection_factor,
                   collection_offset,
                   collection_include_current,
                   currency,
                   inactive,
                   frozen,
                   forentity,
                   org,
                   division,
                   partition,
                   description,
                   finish)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(value=dictionary.login,
                                           type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.entity,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.schedule,
                                            type_callable=lambda value: BillingScheduleEnum.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.schedule_factor,
                                            type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(value=dictionary.start,
                                            type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(value=dictionary.collection,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.collection_factor,
                                            type_callable=lambda value: CollectionFactorEnum.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.collection_offset,
                                            type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(value=dictionary.collection_include_current,
                                            type_callable=lambda value: CollectionIncludeCurrentEnum.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.currency,
                                            type_callable=lambda value: CurrencyEnum.validate(value),
                                            is_value_nullable=True) \
                and APIHelper.is_valid_type(value=dictionary.inactive,
                                            type_callable=lambda value: InactiveEnum.validate(value)) \
                and APIHelper.is_valid_type(value=dictionary.frozen,
                                            type_callable=lambda value: FrozenEnum.validate(value))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(value=dictionary.get('login'),
                                       type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('entity'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('schedule'),
                                        type_callable=lambda value: BillingScheduleEnum.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('scheduleFactor'),
                                        type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(value=dictionary.get('start'),
                                        type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(value=dictionary.get('collection'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('collectionFactor'),
                                        type_callable=lambda value: CollectionFactorEnum.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('collectionOffset'),
                                        type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(value=dictionary.get('collectionIncludeCurrent'),
                                        type_callable=lambda value: CollectionIncludeCurrentEnum.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('currency'),
                                        type_callable=lambda value: CurrencyEnum.validate(value),
                                        is_value_nullable=True) \
            and APIHelper.is_valid_type(value=dictionary.get('inactive'),
                                        type_callable=lambda value: InactiveEnum.validate(value)) \
            and APIHelper.is_valid_type(value=dictionary.get('frozen'),
                                        type_callable=lambda value: FrozenEnum.validate(value))

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!r}, '
                f'entity={self.entity!r}, '
                f'forentity={(self.forentity if hasattr(self, "forentity") else None)!r}, '
                f'org={(self.org if hasattr(self, "org") else None)!r}, '
                f'division={(self.division if hasattr(self, "division") else None)!r}, '
                f'partition={(self.partition if hasattr(self, "partition") else None)!r}, '
                f'description={(self.description if hasattr(self, "description") else None)!r}, '
                f'schedule={self.schedule!r}, '
                f'schedule_factor={self.schedule_factor!r}, '
                f'start={self.start!r}, '
                f'finish={(self.finish if hasattr(self, "finish") else None)!r}, '
                f'collection={self.collection!r}, '
                f'collection_factor={self.collection_factor!r}, '
                f'collection_offset={self.collection_offset!r}, '
                f'collection_include_current={self.collection_include_current!r}, '
                f'currency={self.currency!r}, '
                f'inactive={self.inactive!r}, '
                f'frozen={self.frozen!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!s}, '
                f'entity={self.entity!s}, '
                f'forentity={(self.forentity if hasattr(self, "forentity") else None)!s}, '
                f'org={(self.org if hasattr(self, "org") else None)!s}, '
                f'division={(self.division if hasattr(self, "division") else None)!s}, '
                f'partition={(self.partition if hasattr(self, "partition") else None)!s}, '
                f'description={(self.description if hasattr(self, "description") else None)!s}, '
                f'schedule={self.schedule!s}, '
                f'schedule_factor={self.schedule_factor!s}, '
                f'start={self.start!s}, '
                f'finish={(self.finish if hasattr(self, "finish") else None)!s}, '
                f'collection={self.collection!s}, '
                f'collection_factor={self.collection_factor!s}, '
                f'collection_offset={self.collection_offset!s}, '
                f'collection_include_current={self.collection_include_current!s}, '
                f'currency={self.currency!s}, '
                f'inactive={self.inactive!s}, '
                f'frozen={self.frozen!s})')
