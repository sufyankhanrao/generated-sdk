"""payrix.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from payrix.api_helper import APIHelper


class DecisionActionsPostRequest(object):
    """Implementation of the 'decisionActionsPostRequest' model.

    Attributes:
        decision (str): The identifier of the Decision to which this resource
            applies
        action (DescisionActionsActionEnum): The action to take when this
            check fails.  <details> <summary>Valid Values</summary>  - `1` -
            **Block txn, will never be processed. The Entity is sent to the
            manual review queue.** - `3` - **Hold txn, will not be captured.**
            - `4` - **Reserve txn, funds should be reserved.** - `5` - **Block
            current activity, no change for merchant.** - `8` - **We onboard
            the merchant and wait for manual check later.**  </details>
        application (ApplicationEnum): Where the action defined by this
            DecisionAction should apply.  <details> <summary>Valid
            Values</summary>  - `account` - **Account type Decision.** - `txn`
            - **Txn type Decision.** - `entity` - **Entity type Decision.**
            </details>
        score_type (ScoreTypeEnum): The type of score result on the related
            Decision.  <details> <summary>Valid Values</summary>  - `low` -
            **Only applies if the check hit the low of the parent decision.**
            - `high` - **Only applies if the check hit the high of the parent
            decision.** - `none` - **Only applies if the check did not hit the
            high or low of the parent decision.**  </details>
        mtype (DecisionActionTypeEnum): The type of DecisionAction.  <details>
            <summary>Valid Values</summary>  - `equal` - **Equal.** -
            `notEqual` - **Not Equal.** - `contains` - **Contains.** -
            `greater` - **Greater.** - `less` - **Less.**  </details>
        field (str): The result field to check.
        score (str): The score to check.
        data (str): The decisionAction data will be matched with
            verificationReuslts data.
        message (str): The decisionAction message will be matched with
            verificationReuslts message.
        code (str): The decisionAction code will be matched with
            verificationReuslts code.
        grouping (str): A name for a group of decisionActions to be applied in
            conjunction when evaluating this DecisionAction; when grouping is
            used, the DecisionActions will not apply unless they all match.
        inactive (InactiveEnum): Whether this resource is marked as inactive.
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen.
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "decision": "decision",
        "inactive": "inactive",
        "frozen": "frozen",
        "action": "action",
        "application": "application",
        "score_type": "scoreType",
        "mtype": "type",
        "field": "field",
        "score": "score",
        "data": "data",
        "message": "message",
        "code": "code",
        "grouping": "grouping",
    }

    _optionals = [
        "action",
        "application",
        "score_type",
        "mtype",
        "field",
        "score",
        "data",
        "message",
        "code",
        "grouping",
    ]

    _nullables = [
        "grouping",
    ]

    def __init__(self,
                 decision=None,
                 inactive=0,
                 frozen=0,
                 action=APIHelper.SKIP,
                 application=APIHelper.SKIP,
                 score_type=APIHelper.SKIP,
                 mtype=APIHelper.SKIP,
                 field=APIHelper.SKIP,
                 score=APIHelper.SKIP,
                 data=APIHelper.SKIP,
                 message=APIHelper.SKIP,
                 code=APIHelper.SKIP,
                 grouping=APIHelper.SKIP):
        """Initialize a DecisionActionsPostRequest instance."""
        # Initialize members of the class
        self.decision = decision
        if action is not APIHelper.SKIP:
            self.action = action
        if application is not APIHelper.SKIP:
            self.application = application
        if score_type is not APIHelper.SKIP:
            self.score_type = score_type
        if mtype is not APIHelper.SKIP:
            self.mtype = mtype
        if field is not APIHelper.SKIP:
            self.field = field
        if score is not APIHelper.SKIP:
            self.score = score
        if data is not APIHelper.SKIP:
            self.data = data
        if message is not APIHelper.SKIP:
            self.message = message
        if code is not APIHelper.SKIP:
            self.code = code
        if grouping is not APIHelper.SKIP:
            self.grouping = grouping
        self.inactive = inactive
        self.frozen = frozen

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        decision =\
            dictionary.get("decision")\
            if dictionary.get("decision") else None
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        action =\
            dictionary.get("action")\
            if dictionary.get("action") else APIHelper.SKIP
        application =\
            dictionary.get("application")\
            if dictionary.get("application") else APIHelper.SKIP
        score_type =\
            dictionary.get("scoreType")\
            if dictionary.get("scoreType") else APIHelper.SKIP
        mtype =\
            dictionary.get("type")\
            if dictionary.get("type") else APIHelper.SKIP
        field =\
            dictionary.get("field")\
            if dictionary.get("field") else APIHelper.SKIP
        score =\
            dictionary.get("score")\
            if dictionary.get("score") else APIHelper.SKIP
        data =\
            dictionary.get("data")\
            if dictionary.get("data") else APIHelper.SKIP
        message =\
            dictionary.get("message")\
            if dictionary.get("message") else APIHelper.SKIP
        code =\
            dictionary.get("code")\
            if dictionary.get("code") else APIHelper.SKIP
        grouping =\
            dictionary.get("grouping")\
            if "grouping" in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(decision,
                   inactive,
                   frozen,
                   action,
                   application,
                   score_type,
                   mtype,
                   field,
                   score,
                   data,
                   message,
                   code,
                   grouping)

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"decision={self.decision!r}, "
                f"action={(self.action if hasattr(self, 'action') else None)!r}, "
                f"application={(self.application
                     if hasattr(self, 'application') else None)!r}, "
                f"score_type={(self.score_type
                     if hasattr(self, 'score_type') else None)!r}, "
                f"mtype={(self.mtype if hasattr(self, 'mtype') else None)!r}, "
                f"field={(self.field if hasattr(self, 'field') else None)!r}, "
                f"score={(self.score if hasattr(self, 'score') else None)!r}, "
                f"data={(self.data if hasattr(self, 'data') else None)!r}, "
                f"message={(self.message
                     if hasattr(self, 'message') else None)!r}, "
                f"code={(self.code if hasattr(self, 'code') else None)!r}, "
                f"grouping={(self.grouping
                     if hasattr(self, 'grouping') else None)!r}, "
                f"inactive={self.inactive!r}, "
                f"frozen={self.frozen!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"decision={self.decision!s}, "
                f"action={(self.action if hasattr(self, 'action') else None)!s}, "
                f"application={(self.application
                     if hasattr(self, 'application') else None)!s}, "
                f"score_type={(self.score_type
                     if hasattr(self, 'score_type') else None)!s}, "
                f"mtype={(self.mtype if hasattr(self, 'mtype') else None)!s}, "
                f"field={(self.field if hasattr(self, 'field') else None)!s}, "
                f"score={(self.score if hasattr(self, 'score') else None)!s}, "
                f"data={(self.data if hasattr(self, 'data') else None)!s}, "
                f"message={(self.message
                     if hasattr(self, 'message') else None)!s}, "
                f"code={(self.code if hasattr(self, 'code') else None)!s}, "
                f"grouping={(self.grouping
                     if hasattr(self, 'grouping') else None)!s}, "
                f"inactive={self.inactive!s}, "
                f"frozen={self.frozen!s})")
