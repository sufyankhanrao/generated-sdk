# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper


class PayoutPutRequest(object):

    """Implementation of the 'payoutPutRequest' model.

    Attributes:
        login (str): The Login that owns this resource.
        account (str): The token of the Account that this Payout is associated
            with.  This account will either receive the funds or be debited
            for the funds every time a Disbursement occurs, depending on the
            direction of the Disbursement.
        entity (str): The identifier of the Entity that this Payout is
            associated with.
        billing (str): The identifier of a Billing that this Payout is
            associated with. Payout associated with a Billing record will be
            used to pay for Statements.
        payout_flow (str): The identifier of the PayoutFlow associated with
            this Payout.
        name (str): The name of this Payout.  This field is stored as a text
            string and must be between 0 and 100 characters long.
        description (str): A description of this Payout.  This field is stored
            as a text string and must be between 0 and 100 characters long.
        schedule (PayoutScheduleEnum): The schedule that determines when the
            Payout resource that is created should be triggered to be paid. 
            <details> <summary>Valid Values</summary>  - `1` - **Daily.** The
            Payout is paid every day. - `2` - **Weekly.** The Payout is paid
            every week. - `3` - **Monthly.** The Payout is paid every month. -
            `4` - **Annually.** The Payout is paid every year. - `5` -
            **Single.** The Payout is a one-off payment.  </details>
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, if it is set to a
            duration-based trigger, such as daily, weekly, monthly, or
            annually.  This field is specified as an integer and its value
            determines how the interval is multiplied.
        start (int): The date on which payment of the Payout should start. 
            The date is specified as an eight digit string in YYYYMMDD format,
            for example, '20160120' for January 20, 2016.  The value of this
            field must represent a date in the future, or the present date.
        currency (CurrencyEnum): The currency of the amount in this Payout.
            This field is only required when Um is set to ACTUAL. If this
            field is not set we will process disbursements for all currencies.
            See <a href="https://www.iban.com/currency-codes"
            target="_blank">Currency codes</a>  for all valid values.
        um (PayoutUmEnum): The unit of measure for this Payout is the
            percentage of funds.  If the Entity has a negative balance of $10
            and the amount is set to 10000 (100%),  then $10 will be drawn
            from their account to fully replenish the balance to $0. 
            <details> <summary>Valid Values</summary>  - `1` - **Percentage
            unit measurement.** (Percentage of Funds). - `2` - **Actual unit
            measurement.** (Exact Currency Amount). - `3` - **Negative
            Percentage unit measurement.** (Replenish account by percent
            negative back to $0).  </details>
        amount (int): The total amount of this Payout.  The units used in this
            field are determined by the value of the 'um' field on the Payout.
            If the 'um' field is set to '1' or '3', then this field specifies
            the Payout percentage to levy in basis points. If the 'um' field
            is set to '2', then this field specifies the Payout in cents.
        minimum (int): The threshold that will ensure no disbursement is
            generated if it doesn't reach the minimum value.
        maximum (int): The maximum threshold for a disbursement. Any amount in
            a disbursement exceeding this value will not be released, and will
            roll over to the next disbursement.
        float (int): An optional field indicating the minimum balance you want
            to maintain, despite any Payouts occurring. If the Payout would
            reduce the balance to below this value, then it is not processed. 
            This field is specified as an integer in cents.  For example, a
            float value of 1000 would ensure that a balance of 10 USD is
            maintained at all times.
        secondary_descriptor (str): The secondary billing descriptor to appear
            on the bank statements for the payout.
        skip_off_days (SkipOffDaysEnum): Whether to skip the creation of
            disbursements on holidays and weekends.  <details> <summary>Valid
            Values</summary>  - `0` - **Do not skip Holidays and Weekends.**
            Disbursement will be generated in a Requested status and process
            the next business day. - `1` - **Skip Holidays and Weekends.**
            IMPORTANT: We do not advise setting this for weekly, monthly, or
            yearly Payout schedules as the disbursement will skip and not be
            generated until the next scheduled date.  </details>
        same_day (SameDayEnum): Whether sameDay payout is enabled or disabled.
            <details> <summary>Valid Values</summary>  - `0` - **Disabled** -
            `1` - **Enabled**  </details>
        inactive (InactiveEnum): Whether this resource is marked as inactive. 
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen. 
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "login": 'login',
        "account": 'account',
        "entity": 'entity',
        "billing": 'billing',
        "payout_flow": 'payoutFlow',
        "name": 'name',
        "description": 'description',
        "schedule": 'schedule',
        "schedule_factor": 'scheduleFactor',
        "start": 'start',
        "currency": 'currency',
        "um": 'um',
        "amount": 'amount',
        "minimum": 'minimum',
        "maximum": 'maximum',
        "float": 'float',
        "secondary_descriptor": 'secondaryDescriptor',
        "skip_off_days": 'skipOffDays',
        "same_day": 'sameDay',
        "inactive": 'inactive',
        "frozen": 'frozen'
    }

    _optionals = [
        'login',
        'account',
        'entity',
        'billing',
        'payout_flow',
        'name',
        'description',
        'schedule',
        'schedule_factor',
        'start',
        'currency',
        'um',
        'amount',
        'minimum',
        'maximum',
        'float',
        'secondary_descriptor',
        'skip_off_days',
        'same_day',
        'inactive',
        'frozen',
    ]

    _nullables = [
        'currency',
    ]

    def __init__(self,
                 login=APIHelper.SKIP,
                 account=APIHelper.SKIP,
                 entity=APIHelper.SKIP,
                 billing=APIHelper.SKIP,
                 payout_flow=APIHelper.SKIP,
                 name=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 schedule=APIHelper.SKIP,
                 schedule_factor=APIHelper.SKIP,
                 start=APIHelper.SKIP,
                 currency=APIHelper.SKIP,
                 um=APIHelper.SKIP,
                 amount=APIHelper.SKIP,
                 minimum=APIHelper.SKIP,
                 maximum=APIHelper.SKIP,
                 float=APIHelper.SKIP,
                 secondary_descriptor=APIHelper.SKIP,
                 skip_off_days=APIHelper.SKIP,
                 same_day=APIHelper.SKIP,
                 inactive=0,
                 frozen=0):
        """Constructor for the PayoutPutRequest class"""

        # Initialize members of the class
        if login is not APIHelper.SKIP:
            self.login = login 
        if account is not APIHelper.SKIP:
            self.account = account 
        if entity is not APIHelper.SKIP:
            self.entity = entity 
        if billing is not APIHelper.SKIP:
            self.billing = billing 
        if payout_flow is not APIHelper.SKIP:
            self.payout_flow = payout_flow 
        if name is not APIHelper.SKIP:
            self.name = name 
        if description is not APIHelper.SKIP:
            self.description = description 
        if schedule is not APIHelper.SKIP:
            self.schedule = schedule 
        if schedule_factor is not APIHelper.SKIP:
            self.schedule_factor = schedule_factor 
        if start is not APIHelper.SKIP:
            self.start = start 
        if currency is not APIHelper.SKIP:
            self.currency = currency 
        if um is not APIHelper.SKIP:
            self.um = um 
        if amount is not APIHelper.SKIP:
            self.amount = amount 
        if minimum is not APIHelper.SKIP:
            self.minimum = minimum 
        if maximum is not APIHelper.SKIP:
            self.maximum = maximum 
        if float is not APIHelper.SKIP:
            self.float = float 
        if secondary_descriptor is not APIHelper.SKIP:
            self.secondary_descriptor = secondary_descriptor 
        if skip_off_days is not APIHelper.SKIP:
            self.skip_off_days = skip_off_days 
        if same_day is not APIHelper.SKIP:
            self.same_day = same_day 
        self.inactive = inactive 
        self.frozen = frozen 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        login = dictionary.get("login") if dictionary.get("login") else APIHelper.SKIP
        account = dictionary.get("account") if dictionary.get("account") else APIHelper.SKIP
        entity = dictionary.get("entity") if dictionary.get("entity") else APIHelper.SKIP
        billing = dictionary.get("billing") if dictionary.get("billing") else APIHelper.SKIP
        payout_flow = dictionary.get("payoutFlow") if dictionary.get("payoutFlow") else APIHelper.SKIP
        name = dictionary.get("name") if dictionary.get("name") else APIHelper.SKIP
        description = dictionary.get("description") if dictionary.get("description") else APIHelper.SKIP
        schedule = dictionary.get("schedule") if dictionary.get("schedule") else APIHelper.SKIP
        schedule_factor = dictionary.get("scheduleFactor") if dictionary.get("scheduleFactor") else APIHelper.SKIP
        start = dictionary.get("start") if dictionary.get("start") else APIHelper.SKIP
        currency = dictionary.get("currency") if "currency" in dictionary.keys() else APIHelper.SKIP
        um = dictionary.get("um") if dictionary.get("um") else APIHelper.SKIP
        amount = dictionary.get("amount") if dictionary.get("amount") else APIHelper.SKIP
        minimum = dictionary.get("minimum") if dictionary.get("minimum") else APIHelper.SKIP
        maximum = dictionary.get("maximum") if dictionary.get("maximum") else APIHelper.SKIP
        float = dictionary.get("float") if dictionary.get("float") else APIHelper.SKIP
        secondary_descriptor = dictionary.get("secondaryDescriptor") if dictionary.get("secondaryDescriptor") else APIHelper.SKIP
        skip_off_days = dictionary.get("skipOffDays") if dictionary.get("skipOffDays") else APIHelper.SKIP
        same_day = dictionary.get("sameDay") if dictionary.get("sameDay") else APIHelper.SKIP
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        # Return an object of this model
        return cls(login,
                   account,
                   entity,
                   billing,
                   payout_flow,
                   name,
                   description,
                   schedule,
                   schedule_factor,
                   start,
                   currency,
                   um,
                   amount,
                   minimum,
                   maximum,
                   float,
                   secondary_descriptor,
                   skip_off_days,
                   same_day,
                   inactive,
                   frozen)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'login={(self.login if hasattr(self, "login") else None)!r}, '
                f'account={(self.account if hasattr(self, "account") else None)!r}, '
                f'entity={(self.entity if hasattr(self, "entity") else None)!r}, '
                f'billing={(self.billing if hasattr(self, "billing") else None)!r}, '
                f'payout_flow={(self.payout_flow if hasattr(self, "payout_flow") else None)!r}, '
                f'name={(self.name if hasattr(self, "name") else None)!r}, '
                f'description={(self.description if hasattr(self, "description") else None)!r}, '
                f'schedule={(self.schedule if hasattr(self, "schedule") else None)!r}, '
                f'schedule_factor={(self.schedule_factor if hasattr(self, "schedule_factor") else None)!r}, '
                f'start={(self.start if hasattr(self, "start") else None)!r}, '
                f'currency={(self.currency if hasattr(self, "currency") else None)!r}, '
                f'um={(self.um if hasattr(self, "um") else None)!r}, '
                f'amount={(self.amount if hasattr(self, "amount") else None)!r}, '
                f'minimum={(self.minimum if hasattr(self, "minimum") else None)!r}, '
                f'maximum={(self.maximum if hasattr(self, "maximum") else None)!r}, '
                f'float={(self.float if hasattr(self, "float") else None)!r}, '
                f'secondary_descriptor={(self.secondary_descriptor if hasattr(self, "secondary_descriptor") else None)!r}, '
                f'skip_off_days={(self.skip_off_days if hasattr(self, "skip_off_days") else None)!r}, '
                f'same_day={(self.same_day if hasattr(self, "same_day") else None)!r}, '
                f'inactive={(self.inactive if hasattr(self, "inactive") else None)!r}, '
                f'frozen={(self.frozen if hasattr(self, "frozen") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'login={(self.login if hasattr(self, "login") else None)!s}, '
                f'account={(self.account if hasattr(self, "account") else None)!s}, '
                f'entity={(self.entity if hasattr(self, "entity") else None)!s}, '
                f'billing={(self.billing if hasattr(self, "billing") else None)!s}, '
                f'payout_flow={(self.payout_flow if hasattr(self, "payout_flow") else None)!s}, '
                f'name={(self.name if hasattr(self, "name") else None)!s}, '
                f'description={(self.description if hasattr(self, "description") else None)!s}, '
                f'schedule={(self.schedule if hasattr(self, "schedule") else None)!s}, '
                f'schedule_factor={(self.schedule_factor if hasattr(self, "schedule_factor") else None)!s}, '
                f'start={(self.start if hasattr(self, "start") else None)!s}, '
                f'currency={(self.currency if hasattr(self, "currency") else None)!s}, '
                f'um={(self.um if hasattr(self, "um") else None)!s}, '
                f'amount={(self.amount if hasattr(self, "amount") else None)!s}, '
                f'minimum={(self.minimum if hasattr(self, "minimum") else None)!s}, '
                f'maximum={(self.maximum if hasattr(self, "maximum") else None)!s}, '
                f'float={(self.float if hasattr(self, "float") else None)!s}, '
                f'secondary_descriptor={(self.secondary_descriptor if hasattr(self, "secondary_descriptor") else None)!s}, '
                f'skip_off_days={(self.skip_off_days if hasattr(self, "skip_off_days") else None)!s}, '
                f'same_day={(self.same_day if hasattr(self, "same_day") else None)!s}, '
                f'inactive={(self.inactive if hasattr(self, "inactive") else None)!s}, '
                f'frozen={(self.frozen if hasattr(self, "frozen") else None)!s})')
