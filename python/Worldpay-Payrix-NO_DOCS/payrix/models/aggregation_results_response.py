# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper


class AggregationResultsResponse(object):

    """Implementation of the 'aggregationResultsResponse' model.

    Attributes:
        id (str): The ID of this resource.
        created (str): The date and time at which this resource was created.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        modified (str): The date and time at which this resource was modified.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        creator (str | LoginsResponse | None): The model property of type str
            | LoginsResponse | None.
        modifier (str): The identifier of the Login that last modified this
            resource.
        aggregation_result_group (str): The identifier of the
            AggregationResultGroup that this AggregationResult refers to.
        grouping (str): Grouping is a process used in data aggregation to
            organize data into specific categories or groups based on certain
            attributes. This allows for detailed analysis and reporting on
            subsets of data. For example, grouping transactions by merchant
            and payment method enables you to see the breakdown of
            transactions for each merchant and payment method combination.
        field (str): The field of the resource where calculations were made
            based on.  This field is stored as a text string and must be
            between 1 and 100 characters long.
        count (int): The value calculated by the count aggregation function. 
            This field is specified as an integer.
        sum (float): The value calculated by the sum aggregation function. 
            This field is specified in cents(up to three decimal points).
        min (float): The value calculated by the min aggregation function. 
            This field is specified in cents(up to three decimal points).
        max (float): The value calculated by the max aggregation function. 
            This field is specified in cents(up to three decimal points).

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "id": 'id',
        "created": 'created',
        "modified": 'modified',
        "creator": 'creator',
        "modifier": 'modifier',
        "aggregation_result_group": 'aggregationResultGroup',
        "grouping": 'grouping',
        "field": 'field',
        "count": 'count',
        "sum": 'sum',
        "min": 'min',
        "max": 'max'
    }

    _optionals = [
        'id',
        'created',
        'modified',
        'creator',
        'modifier',
        'aggregation_result_group',
        'grouping',
        'field',
        'count',
        'sum',
        'min',
        'max',
    ]

    def __init__(self,
                 id=APIHelper.SKIP,
                 created=APIHelper.SKIP,
                 modified=APIHelper.SKIP,
                 creator=APIHelper.SKIP,
                 modifier=APIHelper.SKIP,
                 aggregation_result_group=APIHelper.SKIP,
                 grouping=APIHelper.SKIP,
                 field=APIHelper.SKIP,
                 count=APIHelper.SKIP,
                 sum=APIHelper.SKIP,
                 min=APIHelper.SKIP,
                 max=APIHelper.SKIP):
        """Constructor for the AggregationResultsResponse class"""

        # Initialize members of the class
        if id is not APIHelper.SKIP:
            self.id = id 
        if created is not APIHelper.SKIP:
            self.created = created 
        if modified is not APIHelper.SKIP:
            self.modified = modified 
        if creator is not APIHelper.SKIP:
            self.creator = creator 
        if modifier is not APIHelper.SKIP:
            self.modifier = modifier 
        if aggregation_result_group is not APIHelper.SKIP:
            self.aggregation_result_group = aggregation_result_group 
        if grouping is not APIHelper.SKIP:
            self.grouping = grouping 
        if field is not APIHelper.SKIP:
            self.field = field 
        if count is not APIHelper.SKIP:
            self.count = count 
        if sum is not APIHelper.SKIP:
            self.sum = sum 
        if min is not APIHelper.SKIP:
            self.min = min 
        if max is not APIHelper.SKIP:
            self.max = max 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        from payrix.utilities.union_type_lookup import UnionTypeLookUp

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        id = dictionary.get("id") if dictionary.get("id") else APIHelper.SKIP
        created = dictionary.get("created") if dictionary.get("created") else APIHelper.SKIP
        modified = dictionary.get("modified") if dictionary.get("modified") else APIHelper.SKIP
        creator = APIHelper.deserialize_union_type(UnionTypeLookUp.get('AggregationResultsResponseCreator'), dictionary.get('creator'), False) if dictionary.get('creator') is not None else APIHelper.SKIP
        modifier = dictionary.get("modifier") if dictionary.get("modifier") else APIHelper.SKIP
        aggregation_result_group = dictionary.get("aggregationResultGroup") if dictionary.get("aggregationResultGroup") else APIHelper.SKIP
        grouping = dictionary.get("grouping") if dictionary.get("grouping") else APIHelper.SKIP
        field = dictionary.get("field") if dictionary.get("field") else APIHelper.SKIP
        count = dictionary.get("count") if dictionary.get("count") else APIHelper.SKIP
        sum = dictionary.get("sum") if dictionary.get("sum") else APIHelper.SKIP
        min = dictionary.get("min") if dictionary.get("min") else APIHelper.SKIP
        max = dictionary.get("max") if dictionary.get("max") else APIHelper.SKIP
        # Return an object of this model
        return cls(id,
                   created,
                   modified,
                   creator,
                   modifier,
                   aggregation_result_group,
                   grouping,
                   field,
                   count,
                   sum,
                   min,
                   max)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'id={(self.id if hasattr(self, "id") else None)!r}, '
                f'created={(self.created if hasattr(self, "created") else None)!r}, '
                f'modified={(self.modified if hasattr(self, "modified") else None)!r}, '
                f'creator={(self.creator if hasattr(self, "creator") else None)!r}, '
                f'modifier={(self.modifier if hasattr(self, "modifier") else None)!r}, '
                f'aggregation_result_group={(self.aggregation_result_group if hasattr(self, "aggregation_result_group") else None)!r}, '
                f'grouping={(self.grouping if hasattr(self, "grouping") else None)!r}, '
                f'field={(self.field if hasattr(self, "field") else None)!r}, '
                f'count={(self.count if hasattr(self, "count") else None)!r}, '
                f'sum={(self.sum if hasattr(self, "sum") else None)!r}, '
                f'min={(self.min if hasattr(self, "min") else None)!r}, '
                f'max={(self.max if hasattr(self, "max") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'id={(self.id if hasattr(self, "id") else None)!s}, '
                f'created={(self.created if hasattr(self, "created") else None)!s}, '
                f'modified={(self.modified if hasattr(self, "modified") else None)!s}, '
                f'creator={(self.creator if hasattr(self, "creator") else None)!s}, '
                f'modifier={(self.modifier if hasattr(self, "modifier") else None)!s}, '
                f'aggregation_result_group={(self.aggregation_result_group if hasattr(self, "aggregation_result_group") else None)!s}, '
                f'grouping={(self.grouping if hasattr(self, "grouping") else None)!s}, '
                f'field={(self.field if hasattr(self, "field") else None)!s}, '
                f'count={(self.count if hasattr(self, "count") else None)!s}, '
                f'sum={(self.sum if hasattr(self, "sum") else None)!s}, '
                f'min={(self.min if hasattr(self, "min") else None)!s}, '
                f'max={(self.max if hasattr(self, "max") else None)!s})')
