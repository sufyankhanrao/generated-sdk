# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper


class DecisionsPostRequest(object):

    """Implementation of the 'decisionsPostRequest' model.

    Attributes:
        login (str): The identifier of the Login that owns this decisions
            resource.
        org (str): If this decision resource relates to an Org, then this
            field stores the identifier of the Org.
        entity (str): If this decision resource relates to an Entity, then
            this field stores the identifier of the Entity.
        decision (str): The identifier of a linked decision resource that acts
            in coordination with this decision. When you define a decision
            attribute here, the referenced decision becomes the 'parent'
            resource. The action field set on the 'parent' resource determines
            the action that occurs if all of the linked decisions fail.
        division (str): Identifier of the division to which the decision
            resource belongs.
        partition (str): Identifier of the partition to which the decision
            resource belongs.
        application (ApplicationEnum): Where the action defined by this
            DecisionAction should apply.  <details> <summary>Valid
            Values</summary>  - `account` - **Account type Decision.** - `txn`
            - **Txn type Decision.** - `entity` - **Entity type Decision.** 
            </details>
        level (str): The levels of decision admin, merchant, division,
            partition.
        mtype (DecisionTypeEnum): The type of check to perform.  <details>
            <summary>Valid Values</summary>  - `merchantFailureLimit` -
            **Exceeded the maximum number of allowed failed authorizations.**
            - `merchantFailureRatio` - **Exceeded the maximum ratio of allowed
            failed authorizations.** - `saleTotalLimit` - **Exceeded the
            maximum allowed sale total value.** - `refundTotalLimit` -
            **Exceeded the maximum allowed refund total value.** -
            `averageSaleCountLimit` - **Exceeded the allowed maximum payment
            size (individual transaction amount).** -
            `merchantRefundSaleRatio` - **Exceeded the maximum allowed ratio
            of refunds to sales.** - `merchantPaymentSuccessLimit` - **This is
            used to check if the merchant has charged the same payment more
            than X times on a given period of time.** - `ipFailureLimit` -
            **Exceeded the maximum allowed number of failed authorizations for
            a particular IP address.** - `ipFailureRatio` - **Exceeded the
            maximum allowed ratio of failed authorizations for a particular IP
            address.** - `inactiveMerchant` - **The Merchant is not active.**
            - `merchantPaymentFailureLimit` - **Exceeded the maximum allowed
            number of failed transactions.** -
            `merchantCaptureWithoutAuthLimit` - **Exceeded the maximum allowed
            number of transactions without authorizations.** -
            `refundWithoutSale` - **Refund transaction does not have an
            associated sale transaction.** - `refundWithoutSaleLimit` -
            **Exceeded the maximum number of refund transactions that do not
            have associated sale transactions.** - `captureAboveAuthLimit` -
            **Exceeded the maximum authorized value for transactions with
            failed authorizations.** - `fraudScore` - **Transaction fraud
            score.** - `cvv` - **CVV.** - `avs` - **AVS.** - `aavs` -
            **AAVS.** - `duplicateTxn` - **Duplicate transaction.** -
            `merchantMatch` - **Transaction matches merchant details.** -
            `currencyConversion` - **Transaction triggers currency
            conversion.** - `settledCurrencyMismatch` - **Transaction settled
            currency mismatch.** - `initialTxn` - **Initial transaction of
            this type.** - `similarTotalLimit` - **Exceeded the limit of
            transactions with equal totals.** - `similarTotalRatio` -
            **Exceeded the ratio of transactions with equal totals.** -
            `saleTotalMinimum` - **Minimum transaction amount.** - `limit` -
            **Exceeded the maximum allowed number of authorizations.** -
            `ratio` - **This is used to check if similar transactions have
            reached the ratio of auth transactions in a given period of
            time.** - `txnWatchlist` - **Check the transaction data against a
            custom watchlist.** - `balanceRefundLimit` - **This is used to
            check if a merchant has enough balance to process a REFUND
            transaction and it is within the scope of the threshold.** 
            </details>
        target (TargetEnum): The target that this decision should apply at. 
            <details> <summary>Valid Values</summary>  - `activation` -
            **Terminal activation.** - `auth` - **Apply this decision during
            transaction authorization.** - `postauth` - **Immediately after
            authorization.** - `capture` - **Apply this decision during
            transaction capture.** - `refund` - **Apply this decision when
            processing a refund.** - `createEntity` - **createEntity. Process
            decisions during entity creation.** - `underwriting` -
            **Underwriting. Check the members before they are boarded.** -
            `preboard` - **Preboard. Check the Merchant before they are
            boarded.** - `postboard` - **Check the Merchant after they are
            boarded.** - `txn` - **Check the Merchant when they process a
            Transaction.** - `txnVolume` - **Check the Merchant when their
            transaction volume hits a certain amount.** - `payout` - **Check
            the Merchant when a Payout occurs.** - `payoutVolume` - **Check
            the Merchant when the volume of Payouts to the Merchant hits a
            certain amount.**  </details>
        action (DescisionActionEnum): The action to take when this check
            fails.  <details> <summary>Valid Values</summary>  - `0` - **No
            action.** - `1` - **Block txn, will never be processed. The Entity
            is sent to the manual review queue.** - `3` - **Hold txn, will not
            be captured.** - `4` - **Reserve txn, funds should be reserved.**
            - `5` - **Block current activity, no change for merchant.** - `6`
            - **Passed decision(s). Will not be set anywhere, will only be
            used for integration purposes.** - `7` - **We did not have
            policies to process.** - `8` - **We onboard the merchant and wait
            for manual check later.** - `9` - **Schedule the automatic release
            of the reserve.** - `10` - **Hold txn, will not be captured.
            Automatic release when the associated sale is done.**  </details>
        sequence (int): A sequence number to use when applying multiple linked
            decisions: When two or more decisions are linked using their
            'decision' fields, the checks with lower 'sequence' numbers are
            applied first; this field is specified as an integer.
        amount (int): The minimum value that the Transaction must be to target
            this decision, The unit of measure is determined by the type of
            check.
        value (str): The amount that the associated Transaction should be
            compared against. The units for this field depend on the type of
            check: for checks that are based on a ratio, specify the amount as
            a percentage in basis points; for checks that are based on a
            dollar amount, specify the amount in cents; for checks that are
            based on a count, specify the exact value as an integer.
        period (PeriodEnum): A date indicator that determines how far back in
            time time-based checks should be checked. This field works in
            conjunction with the 'periodFactor' field, which multiplies this
            basic period.  <details> <summary>Valid Values</summary>  - `days`
            - **Days. The basic value for the date range is set in days.** -
            `weeks` - **Weeks. The basic value for the date range is set in
            weeks.** - `months` - **Months. The basic value for the date range
            is set in months.** - `years` - **Years. The basic value for the
            date range is set in years.** - `seconds` - **Seconds. The basic
            value for the date range is set in seconds.** - `minutes` -
            **Minutes. The basic value for the date range is set in minutes.**
            - `hours` - **Hours. The basic value for the date range is set in
            hours.**  </details>
        period_factor (int): A multiplier that you can use to adjust the basic
            date range set in the 'period' field, such as daily, weekly,
            monthly, or annually; this field is specified as an integer and
            its value determines how the interval is multiplied.
        schedule (str): The schedule that determines when this Decision is
            triggered to check entities.
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, if it is set to a
            duration-based trigger, such as daily, weekly, monthly, or
            annually. This field is specified as an integer and its value
            determines how the interval is multiplied.
        start (int): The date on which checking of the Decision should start
            is specified as an eight digit string in YYYYMMDD format, for
            example, '20160120' for January 20, 2016; the value of this field
            must represent a date in the future, or the present date.
        finish (int): The date on which checking of the Decision should end.
            The date is specified as an eight digit string in YYYYMMDD format,
            for example, '20160120' for January 20, 2016. The value of this
            field must represent a date in the future.
        low (int): A lower cut-off value for the score in this decision; the
            check fails if the score is equal to or below this value.
        high (int): An upper cut-off value for the score in this decision; the
            check fails if the score is equal to or above this value.
        use_cache (UseCacheEnum): Whether to check for and use existing
            Verifications and Verification Results for this decision. 
            <details> <summary>Valid Values</summary>  - `0` - **Disabled** -
            `1` - **Enabled**  </details>
        cache_time (int): The time caching limit to check for existing
            verification.
        options (int): The options for the Verification are specified as a sum
            of the desired options.
        additional_options (int): The additionalOptions for the Verification
            are specified as a sum of the desired options.
        error_message (str): The error message for the decision: If the field
            is null the error message will be a generic failure message, if
            the field is empty the error message will be a specific error
            message, if the field is set to a string the error message will be
            that string.
        reason (str): The reason for the decision. If the field is null the
            error message will be a generic message, if the field is set to a
            string the reason message will be that string.
        inactive (InactiveEnum): Whether this resource is marked as inactive. 
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen. 
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "login": 'login',
        "application": 'application',
        "level": 'level',
        "mtype": 'type',
        "target": 'target',
        "action": 'action',
        "value": 'value',
        "period": 'period',
        "period_factor": 'periodFactor',
        "schedule_factor": 'scheduleFactor',
        "start": 'start',
        "low": 'low',
        "use_cache": 'useCache',
        "inactive": 'inactive',
        "frozen": 'frozen',
        "org": 'org',
        "entity": 'entity',
        "decision": 'decision',
        "division": 'division',
        "partition": 'partition',
        "sequence": 'sequence',
        "amount": 'amount',
        "schedule": 'schedule',
        "finish": 'finish',
        "high": 'high',
        "cache_time": 'cacheTime',
        "options": 'options',
        "additional_options": 'additionalOptions',
        "error_message": 'errorMessage',
        "reason": 'reason'
    }

    _optionals = [
        'org',
        'entity',
        'decision',
        'division',
        'partition',
        'sequence',
        'amount',
        'schedule',
        'finish',
        'high',
        'cache_time',
        'options',
        'additional_options',
        'error_message',
        'reason',
    ]

    _nullables = [
        'sequence',
        'amount',
        'period_factor',
        'schedule_factor',
    ]

    def __init__(self,
                 login=None,
                 application=None,
                 level=None,
                 mtype=None,
                 target=None,
                 action=None,
                 value=None,
                 period=None,
                 period_factor=None,
                 schedule_factor=None,
                 start=None,
                 low=1,
                 use_cache=0,
                 inactive=0,
                 frozen=0,
                 org=APIHelper.SKIP,
                 entity=APIHelper.SKIP,
                 decision=APIHelper.SKIP,
                 division=APIHelper.SKIP,
                 partition=APIHelper.SKIP,
                 sequence=APIHelper.SKIP,
                 amount=APIHelper.SKIP,
                 schedule=APIHelper.SKIP,
                 finish=APIHelper.SKIP,
                 high=APIHelper.SKIP,
                 cache_time=APIHelper.SKIP,
                 options=0,
                 additional_options=0,
                 error_message=APIHelper.SKIP,
                 reason=APIHelper.SKIP):
        """Constructor for the DecisionsPostRequest class"""

        # Initialize members of the class
        self.login = login 
        if org is not APIHelper.SKIP:
            self.org = org 
        if entity is not APIHelper.SKIP:
            self.entity = entity 
        if decision is not APIHelper.SKIP:
            self.decision = decision 
        if division is not APIHelper.SKIP:
            self.division = division 
        if partition is not APIHelper.SKIP:
            self.partition = partition 
        self.application = application 
        self.level = level 
        self.mtype = mtype 
        self.target = target 
        self.action = action 
        if sequence is not APIHelper.SKIP:
            self.sequence = sequence 
        if amount is not APIHelper.SKIP:
            self.amount = amount 
        self.value = value 
        self.period = period 
        self.period_factor = period_factor 
        if schedule is not APIHelper.SKIP:
            self.schedule = schedule 
        self.schedule_factor = schedule_factor 
        self.start = start 
        if finish is not APIHelper.SKIP:
            self.finish = finish 
        self.low = low 
        if high is not APIHelper.SKIP:
            self.high = high 
        self.use_cache = use_cache 
        if cache_time is not APIHelper.SKIP:
            self.cache_time = cache_time 
        self.options = options 
        self.additional_options = additional_options 
        if error_message is not APIHelper.SKIP:
            self.error_message = error_message 
        if reason is not APIHelper.SKIP:
            self.reason = reason 
        self.inactive = inactive 
        self.frozen = frozen 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        login = dictionary.get("login") if dictionary.get("login") else None
        application = dictionary.get("application") if dictionary.get("application") else None
        level = dictionary.get("level") if dictionary.get("level") else None
        mtype = dictionary.get("type") if dictionary.get("type") else None
        target = dictionary.get("target") if dictionary.get("target") else None
        action = dictionary.get("action") if dictionary.get("action") else None
        value = dictionary.get("value") if dictionary.get("value") else None
        period = dictionary.get("period") if dictionary.get("period") else None
        period_factor = dictionary.get("periodFactor") if dictionary.get("periodFactor") else None
        schedule_factor = dictionary.get("scheduleFactor") if dictionary.get("scheduleFactor") else None
        start = dictionary.get("start") if dictionary.get("start") else None
        low = dictionary.get("low") if dictionary.get("low") else 1
        use_cache = dictionary.get("useCache") if dictionary.get("useCache") else 0
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        org = dictionary.get("org") if dictionary.get("org") else APIHelper.SKIP
        entity = dictionary.get("entity") if dictionary.get("entity") else APIHelper.SKIP
        decision = dictionary.get("decision") if dictionary.get("decision") else APIHelper.SKIP
        division = dictionary.get("division") if dictionary.get("division") else APIHelper.SKIP
        partition = dictionary.get("partition") if dictionary.get("partition") else APIHelper.SKIP
        sequence = dictionary.get("sequence") if "sequence" in dictionary.keys() else APIHelper.SKIP
        amount = dictionary.get("amount") if "amount" in dictionary.keys() else APIHelper.SKIP
        schedule = dictionary.get("schedule") if dictionary.get("schedule") else APIHelper.SKIP
        finish = dictionary.get("finish") if dictionary.get("finish") else APIHelper.SKIP
        high = dictionary.get("high") if dictionary.get("high") else APIHelper.SKIP
        cache_time = dictionary.get("cacheTime") if dictionary.get("cacheTime") else APIHelper.SKIP
        options = dictionary.get("options") if dictionary.get("options") else 0
        additional_options = dictionary.get("additionalOptions") if dictionary.get("additionalOptions") else 0
        error_message = dictionary.get("errorMessage") if dictionary.get("errorMessage") else APIHelper.SKIP
        reason = dictionary.get("reason") if dictionary.get("reason") else APIHelper.SKIP
        # Return an object of this model
        return cls(login,
                   application,
                   level,
                   mtype,
                   target,
                   action,
                   value,
                   period,
                   period_factor,
                   schedule_factor,
                   start,
                   low,
                   use_cache,
                   inactive,
                   frozen,
                   org,
                   entity,
                   decision,
                   division,
                   partition,
                   sequence,
                   amount,
                   schedule,
                   finish,
                   high,
                   cache_time,
                   options,
                   additional_options,
                   error_message,
                   reason)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!r}, '
                f'org={(self.org if hasattr(self, "org") else None)!r}, '
                f'entity={(self.entity if hasattr(self, "entity") else None)!r}, '
                f'decision={(self.decision if hasattr(self, "decision") else None)!r}, '
                f'division={(self.division if hasattr(self, "division") else None)!r}, '
                f'partition={(self.partition if hasattr(self, "partition") else None)!r}, '
                f'application={self.application!r}, '
                f'level={self.level!r}, '
                f'mtype={self.mtype!r}, '
                f'target={self.target!r}, '
                f'action={self.action!r}, '
                f'sequence={(self.sequence if hasattr(self, "sequence") else None)!r}, '
                f'amount={(self.amount if hasattr(self, "amount") else None)!r}, '
                f'value={self.value!r}, '
                f'period={self.period!r}, '
                f'period_factor={self.period_factor!r}, '
                f'schedule={(self.schedule if hasattr(self, "schedule") else None)!r}, '
                f'schedule_factor={self.schedule_factor!r}, '
                f'start={self.start!r}, '
                f'finish={(self.finish if hasattr(self, "finish") else None)!r}, '
                f'low={self.low!r}, '
                f'high={(self.high if hasattr(self, "high") else None)!r}, '
                f'use_cache={self.use_cache!r}, '
                f'cache_time={(self.cache_time if hasattr(self, "cache_time") else None)!r}, '
                f'options={(self.options if hasattr(self, "options") else None)!r}, '
                f'additional_options={(self.additional_options if hasattr(self, "additional_options") else None)!r}, '
                f'error_message={(self.error_message if hasattr(self, "error_message") else None)!r}, '
                f'reason={(self.reason if hasattr(self, "reason") else None)!r}, '
                f'inactive={self.inactive!r}, '
                f'frozen={self.frozen!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!s}, '
                f'org={(self.org if hasattr(self, "org") else None)!s}, '
                f'entity={(self.entity if hasattr(self, "entity") else None)!s}, '
                f'decision={(self.decision if hasattr(self, "decision") else None)!s}, '
                f'division={(self.division if hasattr(self, "division") else None)!s}, '
                f'partition={(self.partition if hasattr(self, "partition") else None)!s}, '
                f'application={self.application!s}, '
                f'level={self.level!s}, '
                f'mtype={self.mtype!s}, '
                f'target={self.target!s}, '
                f'action={self.action!s}, '
                f'sequence={(self.sequence if hasattr(self, "sequence") else None)!s}, '
                f'amount={(self.amount if hasattr(self, "amount") else None)!s}, '
                f'value={self.value!s}, '
                f'period={self.period!s}, '
                f'period_factor={self.period_factor!s}, '
                f'schedule={(self.schedule if hasattr(self, "schedule") else None)!s}, '
                f'schedule_factor={self.schedule_factor!s}, '
                f'start={self.start!s}, '
                f'finish={(self.finish if hasattr(self, "finish") else None)!s}, '
                f'low={self.low!s}, '
                f'high={(self.high if hasattr(self, "high") else None)!s}, '
                f'use_cache={self.use_cache!s}, '
                f'cache_time={(self.cache_time if hasattr(self, "cache_time") else None)!s}, '
                f'options={(self.options if hasattr(self, "options") else None)!s}, '
                f'additional_options={(self.additional_options if hasattr(self, "additional_options") else None)!s}, '
                f'error_message={(self.error_message if hasattr(self, "error_message") else None)!s}, '
                f'reason={(self.reason if hasattr(self, "reason") else None)!s}, '
                f'inactive={self.inactive!s}, '
                f'frozen={self.frozen!s})')
