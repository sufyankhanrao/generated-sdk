"""payrix.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from payrix.api_helper import APIHelper


class PlansResponse(object):
    """Implementation of the 'plansResponse' model.

    Attributes:
        id (str): The ID of this resource.
        created (str): The date and time at which this resource was created.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        modified (str): The date and time at which this resource was modified.
            The format should be YYYY-MM-DD HH:MM:SS.SSSS
        creator (str | LoginsResponse | None): The model property of type str
            | LoginsResponse | None.
        modifier (str): The identifier of the Login that last modified this
            resource.
        merchant (str): The identifier of the Merchant associated with this
            Plan.
        billing (str): The attached billing for which recurring payments
            should be made to pay off statements.
        mtype (PlanTypeEnum): The type of plan.  <details> <summary>Valid
            Values</summary>  - `recurring` - **A recurring payment plan
            (subcription).**  - `installment`  - **A deferred payment
            installment plan.**   </details>
        name (str): The name of this Plan.  This field is stored as a text
            string and must be between 0 and 100 characters long.
        description (str): A description of this Plan.  This field is stored
            as a text string and must be between 0 and 100 characters long.
        txn_description (str): The description of the Txn that will be created
            through this Plan.
        order (str): The order of the Txn that will be created through this
            Plan.
        schedule (PlanScheduleEnum): The schedule that determines when the
            subscription related to this Plan is triggered.  <details>
            <summary>Valid Values</summary>  - `1` - **Daily** - `2` -
            **Weekly** - `3` - **Monthly** - `4` - **Annually**  </details>
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, such as daily, weekly,
            monthly, or annually.  This field is specified as an integer and
            its value determines how the interval is multiplied.
        um (PlanUmEnum): The unit of measure for the amount on the plan.
            <details> <summary>Valid Values</summary>  - `actual` - **An
            actual amount to charge, in cents.** - `percent` - **A percentage
            of another amount, in basis points.**  </details>
        amount (int): The amount to charge with each payment under this Plan.
            This field is specified as an integer in cents.
        max_failures (int): The maximum consecutive amount of payment failures
            to allow for a subscription before inactivating it.
        inactive (InactiveEnum): Whether this resource is marked as inactive.
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen.
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "id": "id",
        "created": "created",
        "modified": "modified",
        "creator": "creator",
        "modifier": "modifier",
        "merchant": "merchant",
        "billing": "billing",
        "mtype": "type",
        "name": "name",
        "description": "description",
        "txn_description": "txnDescription",
        "order": "order",
        "schedule": "schedule",
        "schedule_factor": "scheduleFactor",
        "um": "um",
        "amount": "amount",
        "max_failures": "maxFailures",
        "inactive": "inactive",
        "frozen": "frozen",
    }

    _optionals = [
        "id",
        "created",
        "modified",
        "creator",
        "modifier",
        "merchant",
        "billing",
        "mtype",
        "name",
        "description",
        "txn_description",
        "order",
        "schedule",
        "schedule_factor",
        "um",
        "amount",
        "max_failures",
        "inactive",
        "frozen",
    ]

    def __init__(self,
                 id=APIHelper.SKIP,
                 created=APIHelper.SKIP,
                 modified=APIHelper.SKIP,
                 creator=APIHelper.SKIP,
                 modifier=APIHelper.SKIP,
                 merchant=APIHelper.SKIP,
                 billing=APIHelper.SKIP,
                 mtype=APIHelper.SKIP,
                 name=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 txn_description=APIHelper.SKIP,
                 order=APIHelper.SKIP,
                 schedule=APIHelper.SKIP,
                 schedule_factor=APIHelper.SKIP,
                 um="actual",
                 amount=APIHelper.SKIP,
                 max_failures=APIHelper.SKIP,
                 inactive=0,
                 frozen=0):
        """Initialize a PlansResponse instance."""
        # Initialize members of the class
        if id is not APIHelper.SKIP:
            self.id = id
        if created is not APIHelper.SKIP:
            self.created = created
        if modified is not APIHelper.SKIP:
            self.modified = modified
        if creator is not APIHelper.SKIP:
            self.creator = creator
        if modifier is not APIHelper.SKIP:
            self.modifier = modifier
        if merchant is not APIHelper.SKIP:
            self.merchant = merchant
        if billing is not APIHelper.SKIP:
            self.billing = billing
        if mtype is not APIHelper.SKIP:
            self.mtype = mtype
        if name is not APIHelper.SKIP:
            self.name = name
        if description is not APIHelper.SKIP:
            self.description = description
        if txn_description is not APIHelper.SKIP:
            self.txn_description = txn_description
        if order is not APIHelper.SKIP:
            self.order = order
        if schedule is not APIHelper.SKIP:
            self.schedule = schedule
        if schedule_factor is not APIHelper.SKIP:
            self.schedule_factor = schedule_factor
        self.um = um
        if amount is not APIHelper.SKIP:
            self.amount = amount
        if max_failures is not APIHelper.SKIP:
            self.max_failures = max_failures
        self.inactive = inactive
        self.frozen = frozen

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        from payrix.utilities.union_type_lookup import (
            UnionTypeLookUp,
        )

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        id = dictionary.get("id") if dictionary.get("id") else APIHelper.SKIP
        created =\
            dictionary.get("created")\
            if dictionary.get("created") else APIHelper.SKIP
        modified =\
            dictionary.get("modified")\
            if dictionary.get("modified") else APIHelper.SKIP
        creator = APIHelper.deserialize_union_type(UnionTypeLookUp.get("PlansResponseCreator"), dictionary.get("creator"), False) if dictionary.get("creator") is not None else APIHelper.SKIP
        modifier =\
            dictionary.get("modifier")\
            if dictionary.get("modifier") else APIHelper.SKIP
        merchant =\
            dictionary.get("merchant")\
            if dictionary.get("merchant") else APIHelper.SKIP
        billing =\
            dictionary.get("billing")\
            if dictionary.get("billing") else APIHelper.SKIP
        mtype =\
            dictionary.get("type")\
            if dictionary.get("type") else APIHelper.SKIP
        name =\
            dictionary.get("name")\
            if dictionary.get("name") else APIHelper.SKIP
        description =\
            dictionary.get("description")\
            if dictionary.get("description") else APIHelper.SKIP
        txn_description =\
            dictionary.get("txnDescription")\
            if dictionary.get("txnDescription") else APIHelper.SKIP
        order =\
            dictionary.get("order")\
            if dictionary.get("order") else APIHelper.SKIP
        schedule =\
            dictionary.get("schedule")\
            if dictionary.get("schedule") else APIHelper.SKIP
        schedule_factor =\
            dictionary.get("scheduleFactor")\
            if dictionary.get("scheduleFactor") else APIHelper.SKIP
        um = dictionary.get("um") if dictionary.get("um") else "actual"
        amount =\
            dictionary.get("amount")\
            if dictionary.get("amount") else APIHelper.SKIP
        max_failures =\
            dictionary.get("maxFailures")\
            if dictionary.get("maxFailures") else APIHelper.SKIP
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        # Return an object of this model
        return cls(id,
                   created,
                   modified,
                   creator,
                   modifier,
                   merchant,
                   billing,
                   mtype,
                   name,
                   description,
                   txn_description,
                   order,
                   schedule,
                   schedule_factor,
                   um,
                   amount,
                   max_failures,
                   inactive,
                   frozen)

    @classmethod
    def validate(cls, dictionary):
        """Validate dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """
        if isinstance(dictionary, cls):
            return True

        if not isinstance(dictionary, dict):
            return False

        return True

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"id={(self.id if hasattr(self, 'id') else None)!r}, "
                f"created={(self.created
                     if hasattr(self, 'created') else None)!r}, "
                f"modified={(self.modified
                     if hasattr(self, 'modified') else None)!r}, "
                f"creator={(self.creator
                     if hasattr(self, 'creator') else None)!r}, "
                f"modifier={(self.modifier
                     if hasattr(self, 'modifier') else None)!r}, "
                f"merchant={(self.merchant
                     if hasattr(self, 'merchant') else None)!r}, "
                f"billing={(self.billing
                     if hasattr(self, 'billing') else None)!r}, "
                f"mtype={(self.mtype if hasattr(self, 'mtype') else None)!r}, "
                f"name={(self.name if hasattr(self, 'name') else None)!r}, "
                f"description={(self.description
                     if hasattr(self, 'description') else None)!r}, "
                f"txn_description={(self.txn_description
                     if hasattr(self, 'txn_description') else None)!r}, "
                f"order={(self.order if hasattr(self, 'order') else None)!r}, "
                f"schedule={(self.schedule
                     if hasattr(self, 'schedule') else None)!r}, "
                f"schedule_factor={(self.schedule_factor
                     if hasattr(self, 'schedule_factor') else None)!r}, "
                f"um={(self.um if hasattr(self, 'um') else None)!r}, "
                f"amount={(self.amount if hasattr(self, 'amount') else None)!r}, "
                f"max_failures={(self.max_failures
                     if hasattr(self, 'max_failures') else None)!r}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!r}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"id={(self.id if hasattr(self, 'id') else None)!s}, "
                f"created={(self.created
                     if hasattr(self, 'created') else None)!s}, "
                f"modified={(self.modified
                     if hasattr(self, 'modified') else None)!s}, "
                f"creator={(self.creator
                     if hasattr(self, 'creator') else None)!s}, "
                f"modifier={(self.modifier
                     if hasattr(self, 'modifier') else None)!s}, "
                f"merchant={(self.merchant
                     if hasattr(self, 'merchant') else None)!s}, "
                f"billing={(self.billing
                     if hasattr(self, 'billing') else None)!s}, "
                f"mtype={(self.mtype if hasattr(self, 'mtype') else None)!s}, "
                f"name={(self.name if hasattr(self, 'name') else None)!s}, "
                f"description={(self.description
                     if hasattr(self, 'description') else None)!s}, "
                f"txn_description={(self.txn_description
                     if hasattr(self, 'txn_description') else None)!s}, "
                f"order={(self.order if hasattr(self, 'order') else None)!s}, "
                f"schedule={(self.schedule
                     if hasattr(self, 'schedule') else None)!s}, "
                f"schedule_factor={(self.schedule_factor
                     if hasattr(self, 'schedule_factor') else None)!s}, "
                f"um={(self.um if hasattr(self, 'um') else None)!s}, "
                f"amount={(self.amount if hasattr(self, 'amount') else None)!s}, "
                f"max_failures={(self.max_failures
                     if hasattr(self, 'max_failures') else None)!s}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!s}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!s})")
