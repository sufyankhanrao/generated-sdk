"""payrix.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from payrix.api_helper import APIHelper
from payrix.models.frozen_enum import FrozenEnum
from payrix.models.inactive_enum import InactiveEnum


class HoldsPostRequest(object):
    """Implementation of the 'holdsPostRequest' model.

    Attributes:
        login (str): The identifier of the Login that owns this holds resource.
        verification_ref (str): If this hold resource was triggered through
            Payrix Integration Risk, then this field stores the identifier of
            the VerificationRef.
        released (str): If this hold was released, this will contain the
            timestamp for when it was released. (YYYY-MM-DD HH:II:SS)
        reviewed (str): If this hold was reviewed, this will contain the
            timestamp for when it was reviewed. The format should be
            YYYY-MM-DD HH:MM:SS.
        release_action (ReleaseActionEnum): The final action taken on the hold
            while it's been released.  <details> <summary>Valid
            Values</summary>  - `1` - **Holds released because the hold
            resource was approved.** - `2` - **Holds released because the hold
            resource was cancelled.** - `3` - **Holds released because the
            hold resource was refunded.** - `4` - **Holds released because the
            hold resource was failed.** - `5` - **Expired.**  </details>
        hold_source (HoldSourceEnum): Field created to know the reason for why
            a hold was created.  <details> <summary>Valid Values</summary>  -
            `DS_MODEL_POLICY_RUN` - **DS_MODEL_POLICY_RUN** - `API_DECISION` -
            **API_DECISION** - `POLICY_RUN` - **POLICY_RUN** - `RISK_ALERT` -
            **RISK_ALERT** - `MANUAL` - **MANUAL** - `ERROR` - **ERROR**
            </details>
        hold_source_id (str): reasonid for why a hold was created.
        delayed_funding_start_date (str): The timestamp when hold was
            considered to be delaying funding. The format should be YYYY-MM-DD
            HH:MM:SS.
        delayed_funding_end_date (str): The timestamp when hold stopped
            delaying funding, this might be due to the hold been released,
            cancelled or funded. (YYYY-MM-DD HH:II:SS)
        analyst (str): The person who review the hold applied.
        claimed (str): The timestamp for the most recent update of the analyst
            field. (YYYY-MM-DD HH:II:SS)
        inactive (InactiveEnum): Whether this resource is marked as inactive.
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen.
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "login": "login",
        "inactive": "inactive",
        "frozen": "frozen",
        "verification_ref": "verificationRef",
        "released": "released",
        "reviewed": "reviewed",
        "release_action": "releaseAction",
        "hold_source": "holdSource",
        "hold_source_id": "holdSourceId",
        "delayed_funding_start_date": "delayedFundingStartDate",
        "delayed_funding_end_date": "delayedFundingEndDate",
        "analyst": "analyst",
        "claimed": "claimed",
    }

    _optionals = [
        "verification_ref",
        "released",
        "reviewed",
        "release_action",
        "hold_source",
        "hold_source_id",
        "delayed_funding_start_date",
        "delayed_funding_end_date",
        "analyst",
        "claimed",
    ]

    _nullables = [
        "claimed",
    ]

    def __init__(self,
                 login=None,
                 inactive=0,
                 frozen=0,
                 verification_ref=APIHelper.SKIP,
                 released=APIHelper.SKIP,
                 reviewed=APIHelper.SKIP,
                 release_action=APIHelper.SKIP,
                 hold_source=APIHelper.SKIP,
                 hold_source_id=APIHelper.SKIP,
                 delayed_funding_start_date=APIHelper.SKIP,
                 delayed_funding_end_date=APIHelper.SKIP,
                 analyst=APIHelper.SKIP,
                 claimed=APIHelper.SKIP):
        """Initialize a HoldsPostRequest instance."""
        # Initialize members of the class
        self.login = login
        if verification_ref is not APIHelper.SKIP:
            self.verification_ref = verification_ref
        if released is not APIHelper.SKIP:
            self.released = released
        if reviewed is not APIHelper.SKIP:
            self.reviewed = reviewed
        if release_action is not APIHelper.SKIP:
            self.release_action = release_action
        if hold_source is not APIHelper.SKIP:
            self.hold_source = hold_source
        if hold_source_id is not APIHelper.SKIP:
            self.hold_source_id = hold_source_id
        if delayed_funding_start_date is not APIHelper.SKIP:
            self.delayed_funding_start_date = delayed_funding_start_date
        if delayed_funding_end_date is not APIHelper.SKIP:
            self.delayed_funding_end_date = delayed_funding_end_date
        if analyst is not APIHelper.SKIP:
            self.analyst = analyst
        if claimed is not APIHelper.SKIP:
            self.claimed = claimed
        self.inactive = inactive
        self.frozen = frozen

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        login = dictionary.get("login") if dictionary.get("login") else None
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        verification_ref =\
            dictionary.get("verificationRef")\
            if dictionary.get("verificationRef") else APIHelper.SKIP
        released =\
            dictionary.get("released")\
            if dictionary.get("released") else APIHelper.SKIP
        reviewed =\
            dictionary.get("reviewed")\
            if dictionary.get("reviewed") else APIHelper.SKIP
        release_action =\
            dictionary.get("releaseAction")\
            if dictionary.get("releaseAction") else APIHelper.SKIP
        hold_source =\
            dictionary.get("holdSource")\
            if dictionary.get("holdSource") else APIHelper.SKIP
        hold_source_id =\
            dictionary.get("holdSourceId")\
            if dictionary.get("holdSourceId") else APIHelper.SKIP
        delayed_funding_start_date =\
            dictionary.get("delayedFundingStartDate")\
            if dictionary.get("delayedFundingStartDate") else APIHelper.SKIP
        delayed_funding_end_date =\
            dictionary.get("delayedFundingEndDate")\
            if dictionary.get("delayedFundingEndDate") else APIHelper.SKIP
        analyst =\
            dictionary.get("analyst")\
            if dictionary.get("analyst") else APIHelper.SKIP
        claimed =\
            dictionary.get("claimed")\
            if "claimed" in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(login,
                   inactive,
                   frozen,
                   verification_ref,
                   released,
                   reviewed,
                   release_action,
                   hold_source,
                   hold_source_id,
                   delayed_funding_start_date,
                   delayed_funding_end_date,
                   analyst,
                   claimed)

    @classmethod
    def validate(cls, dictionary):
        """Validate dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """
        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(
                value=dictionary.login,
                type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(
                value=dictionary.inactive,
                type_callable=lambda value: InactiveEnum.validate(value)) \
                and APIHelper.is_valid_type(
                value=dictionary.frozen,
                type_callable=lambda value: FrozenEnum.validate(value))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(
            value=dictionary.get("login"),
            type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("inactive"),
            type_callable=lambda value: InactiveEnum.validate(value)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("frozen"),
            type_callable=lambda value: FrozenEnum.validate(value))

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"login={self.login!r}, "
                f"verification_ref={(self.verification_ref
                     if hasattr(self, 'verification_ref') else None)!r}, "
                f"released={(self.released
                     if hasattr(self, 'released') else None)!r}, "
                f"reviewed={(self.reviewed
                     if hasattr(self, 'reviewed') else None)!r}, "
                f"release_action={(self.release_action
                     if hasattr(self, 'release_action') else None)!r}, "
                f"hold_source={(self.hold_source
                     if hasattr(self, 'hold_source') else None)!r}, "
                f"hold_source_id={(self.hold_source_id
                     if hasattr(self, 'hold_source_id') else None)!r}, "
                f"delayed_funding_start_date={(self.delayed_funding_start_date
                     if hasattr(self, 'delayed_funding_start_date') else None)!r}, "
                f"delayed_funding_end_date={(self.delayed_funding_end_date
                     if hasattr(self, 'delayed_funding_end_date') else None)!r}, "
                f"analyst={(self.analyst
                     if hasattr(self, 'analyst') else None)!r}, "
                f"claimed={(self.claimed
                     if hasattr(self, 'claimed') else None)!r}, "
                f"inactive={self.inactive!r}, "
                f"frozen={self.frozen!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"login={self.login!s}, "
                f"verification_ref={(self.verification_ref
                     if hasattr(self, 'verification_ref') else None)!s}, "
                f"released={(self.released
                     if hasattr(self, 'released') else None)!s}, "
                f"reviewed={(self.reviewed
                     if hasattr(self, 'reviewed') else None)!s}, "
                f"release_action={(self.release_action
                     if hasattr(self, 'release_action') else None)!s}, "
                f"hold_source={(self.hold_source
                     if hasattr(self, 'hold_source') else None)!s}, "
                f"hold_source_id={(self.hold_source_id
                     if hasattr(self, 'hold_source_id') else None)!s}, "
                f"delayed_funding_start_date={(self.delayed_funding_start_date
                     if hasattr(self, 'delayed_funding_start_date') else None)!s}, "
                f"delayed_funding_end_date={(self.delayed_funding_end_date
                     if hasattr(self, 'delayed_funding_end_date') else None)!s}, "
                f"analyst={(self.analyst
                     if hasattr(self, 'analyst') else None)!s}, "
                f"claimed={(self.claimed
                     if hasattr(self, 'claimed') else None)!s}, "
                f"inactive={self.inactive!s}, "
                f"frozen={self.frozen!s})")
