# -*- coding: utf-8 -*-

"""
payrix

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from payrix.api_helper import APIHelper


class MessageThreadsPostRequest(object):

    """Implementation of the 'messageThreadsPostRequest' model.

    Attributes:
        login (str): The identifier of the Login that owns this messageThreads
            resource.
        forlogin (str): The identifier of the receiving Login of this
            messageThreads resource.
        hold (str): The identifier of the Hold that is related to this
            messageThread.
        entity_return (str): This field has the ID from the EntityReturns
            table that hold ACH returns for disbursements or eCheck txns.
        opposing_message_thread (str): Specifies whether this is the opposing
            MessageThread.
        folder (str): Free-form text. By default, a messageThread resource is
            set as 'default'.
        sender (str): Free-form text that represents the name of the sender of
            a messageThread resource.
        recipient (str): Free-form text that represents the name of the
            recipient of a messageThread resource.
        subject (str): Free-form text for adding a subject to a messageThread
            resource.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "login": 'login',
        "folder": 'folder',
        "sender": 'sender',
        "recipient": 'recipient',
        "subject": 'subject',
        "forlogin": 'forlogin',
        "hold": 'hold',
        "entity_return": 'entityReturn',
        "opposing_message_thread": 'opposingMessageThread'
    }

    _optionals = [
        'forlogin',
        'hold',
        'entity_return',
        'opposing_message_thread',
    ]

    def __init__(self,
                 login=None,
                 folder='default',
                 sender=None,
                 recipient=None,
                 subject=None,
                 forlogin=APIHelper.SKIP,
                 hold=APIHelper.SKIP,
                 entity_return=APIHelper.SKIP,
                 opposing_message_thread=APIHelper.SKIP):
        """Constructor for the MessageThreadsPostRequest class"""

        # Initialize members of the class
        self.login = login 
        if forlogin is not APIHelper.SKIP:
            self.forlogin = forlogin 
        if hold is not APIHelper.SKIP:
            self.hold = hold 
        if entity_return is not APIHelper.SKIP:
            self.entity_return = entity_return 
        if opposing_message_thread is not APIHelper.SKIP:
            self.opposing_message_thread = opposing_message_thread 
        self.folder = folder 
        self.sender = sender 
        self.recipient = recipient 
        self.subject = subject 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        login = dictionary.get("login") if dictionary.get("login") else None
        folder = dictionary.get("folder") if dictionary.get("folder") else 'default'
        sender = dictionary.get("sender") if dictionary.get("sender") else None
        recipient = dictionary.get("recipient") if dictionary.get("recipient") else None
        subject = dictionary.get("subject") if dictionary.get("subject") else None
        forlogin = dictionary.get("forlogin") if dictionary.get("forlogin") else APIHelper.SKIP
        hold = dictionary.get("hold") if dictionary.get("hold") else APIHelper.SKIP
        entity_return = dictionary.get("entityReturn") if dictionary.get("entityReturn") else APIHelper.SKIP
        opposing_message_thread = dictionary.get("opposingMessageThread") if dictionary.get("opposingMessageThread") else APIHelper.SKIP
        # Return an object of this model
        return cls(login,
                   folder,
                   sender,
                   recipient,
                   subject,
                   forlogin,
                   hold,
                   entity_return,
                   opposing_message_thread)

    @classmethod
    def validate(cls, dictionary):
        """Validates dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """

        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(value=dictionary.login,
                                           type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.folder,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.sender,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.recipient,
                                            type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(value=dictionary.subject,
                                            type_callable=lambda value: isinstance(value, str))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(value=dictionary.get('login'),
                                       type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('folder'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('sender'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('recipient'),
                                        type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(value=dictionary.get('subject'),
                                        type_callable=lambda value: isinstance(value, str))

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!r}, '
                f'forlogin={(self.forlogin if hasattr(self, "forlogin") else None)!r}, '
                f'hold={(self.hold if hasattr(self, "hold") else None)!r}, '
                f'entity_return={(self.entity_return if hasattr(self, "entity_return") else None)!r}, '
                f'opposing_message_thread={(self.opposing_message_thread if hasattr(self, "opposing_message_thread") else None)!r}, '
                f'folder={self.folder!r}, '
                f'sender={self.sender!r}, '
                f'recipient={self.recipient!r}, '
                f'subject={self.subject!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'login={self.login!s}, '
                f'forlogin={(self.forlogin if hasattr(self, "forlogin") else None)!s}, '
                f'hold={(self.hold if hasattr(self, "hold") else None)!s}, '
                f'entity_return={(self.entity_return if hasattr(self, "entity_return") else None)!s}, '
                f'opposing_message_thread={(self.opposing_message_thread if hasattr(self, "opposing_message_thread") else None)!s}, '
                f'folder={self.folder!s}, '
                f'sender={self.sender!s}, '
                f'recipient={self.recipient!s}, '
                f'subject={self.subject!s})')
