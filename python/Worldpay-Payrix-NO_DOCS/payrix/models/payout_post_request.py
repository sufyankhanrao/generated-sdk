"""payrix.

This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
"""

from payrix.api_helper import APIHelper
from payrix.models.payout_schedule_enum import (
    PayoutScheduleEnum,
)
from payrix.models.payout_um_enum import PayoutUmEnum
from payrix.models.same_day_enum import SameDayEnum
from payrix.models.skip_off_days_enum import (
    SkipOffDaysEnum,
)


class PayoutPostRequest(object):
    """Implementation of the 'payoutPostRequest' model.

    Attributes:
        login (str): The Login that owns this resource.
        account (str): The token of the Account that this Payout is associated
            with.  This account will either receive the funds or be debited
            for the funds every time a Disbursement occurs, depending on the
            direction of the Disbursement.
        entity (str): The identifier of the Entity that this Payout is
            associated with.
        billing (str): The identifier of a Billing that this Payout is
            associated with. Payout associated with a Billing record will be
            used to pay for Statements.
        payout_flow (str): The identifier of the PayoutFlow associated with
            this Payout.
        name (str): The name of this Payout.  This field is stored as a text
            string and must be between 0 and 100 characters long.
        description (str): A description of this Payout.  This field is stored
            as a text string and must be between 0 and 100 characters long.
        schedule (PayoutScheduleEnum): The schedule that determines when the
            Payout resource that is created should be triggered to be paid.
            <details> <summary>Valid Values</summary>  - `1` - **Daily.** The
            Payout is paid every day. - `2` - **Weekly.** The Payout is paid
            every week. - `3` - **Monthly.** The Payout is paid every month. -
            `4` - **Annually.** The Payout is paid every year. - `5` -
            **Single.** The Payout is a one-off payment.  </details>
        schedule_factor (int): A multiplier that you can use to adjust the
            schedule set in the 'schedule' field, if it is set to a
            duration-based trigger, such as daily, weekly, monthly, or
            annually.  This field is specified as an integer and its value
            determines how the interval is multiplied.
        start (int): The date on which payment of the Payout should start.
            The date is specified as an eight digit string in YYYYMMDD format,
            for example, '20160120' for January 20, 2016.  The value of this
            field must represent a date in the future, or the present date.
        currency (CurrencyEnum): The currency of the amount in this Payout.
            \nThis field is only required when Um is set to ACTUAL.\nIf this
            field is not set we will process disbursements for all currencies.
            See <a href="https://www.iban.com/currency-codes"
            target="_blank">Currency codes</a>  for all valid values.
        um (PayoutUmEnum): The unit of measure for this Payout is the
            percentage of funds.  If the Entity has a negative balance of $10
            and the amount is set to 10000 (100%),  then $10 will be drawn
            from their account to fully replenish the balance to $0.
            <details> <summary>Valid Values</summary>  - `1` - **Percentage
            unit measurement.** (Percentage of Funds). - `2` - **Actual unit
            measurement.** (Exact Currency Amount). - `3` - **Negative
            Percentage unit measurement.** (Replenish account by percent
            negative back to $0).  </details>
        amount (int): The total amount of this Payout.  The units used in this
            field are determined by the value of the 'um' field on the Payout.
            If the 'um' field is set to '1' or '3', then this field specifies
            the Payout percentage to levy in basis points. If the 'um' field
            is set to '2', then this field specifies the Payout in cents.
        minimum (int): The threshold that will ensure no disbursement is
            generated if it doesn't reach the minimum value.
        maximum (int): The maximum threshold for a disbursement. Any amount in
            a disbursement exceeding this value will not be released, and will
            roll over to the next disbursement.
        float (int): An optional field indicating the minimum balance you want
            to maintain, despite any Payouts occurring. If the Payout would
            reduce the balance to below this value, then it is not processed.
            This field is specified as an integer in cents.  For example, a
            float value of 1000 would ensure that a balance of 10 USD is
            maintained at all times.
        secondary_descriptor (str): The secondary billing descriptor to appear
            on the bank statements for the payout.
        skip_off_days (SkipOffDaysEnum): Whether to skip the creation of
            disbursements on holidays and weekends.  <details> <summary>Valid
            Values</summary>  - `0` - **Do not skip Holidays and Weekends.**
            Disbursement will be generated in a Requested status and process
            the next business day. - `1` - **Skip Holidays and Weekends.**
            IMPORTANT: We do not advise setting this for weekly, monthly, or
            yearly Payout schedules as the disbursement will skip and not be
            generated until the next scheduled date.  </details>
        same_day (SameDayEnum): Whether sameDay payout is enabled or disabled.
            <details> <summary>Valid Values</summary>  - `0` - **Disabled** -
            `1` - **Enabled**  </details>
        inactive (InactiveEnum): Whether this resource is marked as inactive.
            <details> <summary>Valid Values</summary>  - `0` - **Active** -
            `1` - **Inactive**  </details>
        frozen (FrozenEnum): Whether this resource is marked as frozen.
            <details> <summary>Valid Values</summary>  - `0` - **Not Frozen**
            - `1` - **Frozen**  </details>

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "account": "account",
        "entity": "entity",
        "schedule": "schedule",
        "schedule_factor": "scheduleFactor",
        "start": "start",
        "um": "um",
        "amount": "amount",
        "float": "float",
        "skip_off_days": "skipOffDays",
        "same_day": "sameDay",
        "login": "login",
        "billing": "billing",
        "payout_flow": "payoutFlow",
        "name": "name",
        "description": "description",
        "currency": "currency",
        "minimum": "minimum",
        "maximum": "maximum",
        "secondary_descriptor": "secondaryDescriptor",
        "inactive": "inactive",
        "frozen": "frozen",
    }

    _optionals = [
        "login",
        "billing",
        "payout_flow",
        "name",
        "description",
        "currency",
        "minimum",
        "maximum",
        "secondary_descriptor",
        "inactive",
        "frozen",
    ]

    _nullables = [
        "currency",
    ]

    def __init__(self,
                 account=None,
                 entity=None,
                 schedule=None,
                 schedule_factor=1,
                 start=None,
                 um=None,
                 amount=None,
                 float=0,
                 skip_off_days=None,
                 same_day=0,
                 login=APIHelper.SKIP,
                 billing=APIHelper.SKIP,
                 payout_flow=APIHelper.SKIP,
                 name=APIHelper.SKIP,
                 description=APIHelper.SKIP,
                 currency=APIHelper.SKIP,
                 minimum=APIHelper.SKIP,
                 maximum=APIHelper.SKIP,
                 secondary_descriptor=APIHelper.SKIP,
                 inactive=0,
                 frozen=0):
        """Initialize a PayoutPostRequest instance."""
        # Initialize members of the class
        if login is not APIHelper.SKIP:
            self.login = login
        self.account = account
        self.entity = entity
        if billing is not APIHelper.SKIP:
            self.billing = billing
        if payout_flow is not APIHelper.SKIP:
            self.payout_flow = payout_flow
        if name is not APIHelper.SKIP:
            self.name = name
        if description is not APIHelper.SKIP:
            self.description = description
        self.schedule = schedule
        self.schedule_factor = schedule_factor
        self.start = start
        if currency is not APIHelper.SKIP:
            self.currency = currency
        self.um = um
        self.amount = amount
        if minimum is not APIHelper.SKIP:
            self.minimum = minimum
        if maximum is not APIHelper.SKIP:
            self.maximum = maximum
        self.float = float
        if secondary_descriptor is not APIHelper.SKIP:
            self.secondary_descriptor = secondary_descriptor
        self.skip_off_days = skip_off_days
        self.same_day = same_day
        self.inactive = inactive
        self.frozen = frozen

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Create an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """
        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        account = dictionary.get("account") if dictionary.get("account") else None
        entity = dictionary.get("entity") if dictionary.get("entity") else None
        schedule =\
            dictionary.get("schedule")\
            if dictionary.get("schedule") else None
        schedule_factor =\
            dictionary.get("scheduleFactor")\
            if dictionary.get("scheduleFactor") else 1
        start = dictionary.get("start") if dictionary.get("start") else None
        um = dictionary.get("um") if dictionary.get("um") else None
        amount = dictionary.get("amount") if dictionary.get("amount") else None
        float = dictionary.get("float") if dictionary.get("float") else 0
        skip_off_days =\
            dictionary.get("skipOffDays")\
            if dictionary.get("skipOffDays") else None
        same_day = dictionary.get("sameDay") if dictionary.get("sameDay") else 0
        login =\
            dictionary.get("login")\
            if dictionary.get("login") else APIHelper.SKIP
        billing =\
            dictionary.get("billing")\
            if dictionary.get("billing") else APIHelper.SKIP
        payout_flow =\
            dictionary.get("payoutFlow")\
            if dictionary.get("payoutFlow") else APIHelper.SKIP
        name =\
            dictionary.get("name")\
            if dictionary.get("name") else APIHelper.SKIP
        description =\
            dictionary.get("description")\
            if dictionary.get("description") else APIHelper.SKIP
        currency =\
            dictionary.get("currency")\
            if "currency" in dictionary.keys() else APIHelper.SKIP
        minimum =\
            dictionary.get("minimum")\
            if dictionary.get("minimum") else APIHelper.SKIP
        maximum =\
            dictionary.get("maximum")\
            if dictionary.get("maximum") else APIHelper.SKIP
        secondary_descriptor =\
            dictionary.get("secondaryDescriptor")\
            if dictionary.get("secondaryDescriptor") else APIHelper.SKIP
        inactive = dictionary.get("inactive") if dictionary.get("inactive") else 0
        frozen = dictionary.get("frozen") if dictionary.get("frozen") else 0
        # Return an object of this model
        return cls(account,
                   entity,
                   schedule,
                   schedule_factor,
                   start,
                   um,
                   amount,
                   float,
                   skip_off_days,
                   same_day,
                   login,
                   billing,
                   payout_flow,
                   name,
                   description,
                   currency,
                   minimum,
                   maximum,
                   secondary_descriptor,
                   inactive,
                   frozen)

    @classmethod
    def validate(cls, dictionary):
        """Validate dictionary against class required properties

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            boolean : if dictionary is valid contains required properties.

        """
        if isinstance(dictionary, cls):
            return APIHelper.is_valid_type(
                value=dictionary.account,
                type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(
                value=dictionary.entity,
                type_callable=lambda value: isinstance(value, str)) \
                and APIHelper.is_valid_type(
                value=dictionary.schedule,
                type_callable=lambda value: PayoutScheduleEnum.validate(value)) \
                and APIHelper.is_valid_type(
                value=dictionary.schedule_factor,
                type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(
                value=dictionary.start,
                type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(
                value=dictionary.um,
                type_callable=lambda value: PayoutUmEnum.validate(value)) \
                and APIHelper.is_valid_type(
                value=dictionary.amount,
                type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(
                value=dictionary.float,
                type_callable=lambda value: isinstance(value, int)) \
                and APIHelper.is_valid_type(
                value=dictionary.skip_off_days,
                type_callable=lambda value: SkipOffDaysEnum.validate(value)) \
                and APIHelper.is_valid_type(
                value=dictionary.same_day,
                type_callable=lambda value: SameDayEnum.validate(value))

        if not isinstance(dictionary, dict):
            return False

        return APIHelper.is_valid_type(
            value=dictionary.get("account"),
            type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("entity"),
            type_callable=lambda value: isinstance(value, str)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("schedule"),
            type_callable=lambda value: PayoutScheduleEnum.validate(value)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("scheduleFactor"),
            type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("start"),
            type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("um"),
            type_callable=lambda value: PayoutUmEnum.validate(value)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("amount"),
            type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("float"),
            type_callable=lambda value: isinstance(value, int)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("skipOffDays"),
            type_callable=lambda value: SkipOffDaysEnum.validate(value)) \
            and APIHelper.is_valid_type(
            value=dictionary.get("sameDay"),
            type_callable=lambda value: SameDayEnum.validate(value))

    def __repr__(self):
        """Return a unambiguous string representation."""
        return (f"{self.__class__.__name__}("
                f"login={(self.login if hasattr(self, 'login') else None)!r}, "
                f"account={self.account!r}, "
                f"entity={self.entity!r}, "
                f"billing={(self.billing
                     if hasattr(self, 'billing') else None)!r}, "
                f"payout_flow={(self.payout_flow
                     if hasattr(self, 'payout_flow') else None)!r}, "
                f"name={(self.name if hasattr(self, 'name') else None)!r}, "
                f"description={(self.description
                     if hasattr(self, 'description') else None)!r}, "
                f"schedule={self.schedule!r}, "
                f"schedule_factor={self.schedule_factor!r}, "
                f"start={self.start!r}, "
                f"currency={(self.currency
                     if hasattr(self, 'currency') else None)!r}, "
                f"um={self.um!r}, "
                f"amount={self.amount!r}, "
                f"minimum={(self.minimum
                     if hasattr(self, 'minimum') else None)!r}, "
                f"maximum={(self.maximum
                     if hasattr(self, 'maximum') else None)!r}, "
                f"float={self.float!r}, "
                f"secondary_descriptor={(self.secondary_descriptor
                     if hasattr(self, 'secondary_descriptor') else None)!r}, "
                f"skip_off_days={self.skip_off_days!r}, "
                f"same_day={self.same_day!r}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!r}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!r})")

    def __str__(self):
        """Return a human-readable string representation."""
        return (f"{self.__class__.__name__}("
                f"login={(self.login if hasattr(self, 'login') else None)!s}, "
                f"account={self.account!s}, "
                f"entity={self.entity!s}, "
                f"billing={(self.billing
                     if hasattr(self, 'billing') else None)!s}, "
                f"payout_flow={(self.payout_flow
                     if hasattr(self, 'payout_flow') else None)!s}, "
                f"name={(self.name if hasattr(self, 'name') else None)!s}, "
                f"description={(self.description
                     if hasattr(self, 'description') else None)!s}, "
                f"schedule={self.schedule!s}, "
                f"schedule_factor={self.schedule_factor!s}, "
                f"start={self.start!s}, "
                f"currency={(self.currency
                     if hasattr(self, 'currency') else None)!s}, "
                f"um={self.um!s}, "
                f"amount={self.amount!s}, "
                f"minimum={(self.minimum
                     if hasattr(self, 'minimum') else None)!s}, "
                f"maximum={(self.maximum
                     if hasattr(self, 'maximum') else None)!s}, "
                f"float={self.float!s}, "
                f"secondary_descriptor={(self.secondary_descriptor
                     if hasattr(self, 'secondary_descriptor') else None)!s}, "
                f"skip_off_days={self.skip_off_days!s}, "
                f"same_day={self.same_day!s}, "
                f"inactive={(self.inactive
                     if hasattr(self, 'inactive') else None)!s}, "
                f"frozen={(self.frozen if hasattr(self, 'frozen') else None)!s})")
