# -*- coding: utf-8 -*-

"""
mindbodypublicapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mindbodypublicapi.api_helper import APIHelper


class AddClientToClassRequest(object):

    """Implementation of the 'AddClientToClassRequest' model.

    Attributes:
        client_id (str): The ID of the client who is being booked into the
            class
        class_id (int): The ID of the class into which the client is being
            booked
        test (bool): When `true`, indicates that input information is
            validated, but not committed.<br />  When `false`, the information
            is committed and the database is affected.<br />  Default:
            **false**
        require_payment (bool): When `true`, the client must have an active,
            usable pricing option on their account.<br />  When `false` or
            omitted, an active pricing option is not required to complete the
            client’s booking.
        waitlist (bool): When `true`, indicates that the client should be
            added to a specific class waiting list.<br />  When `false`, the
            client should not be added to the waiting list.
        send_email (bool): When `true`, the subscriber’s configured Booking
            Confirmation automatic email is sent to the client. Note that an
            email is sent only if the client has an email address and
            automatic emails have been set up.<br />  When `false`, indicates
            that the client does not receive emails.<br />  Default: **false**
            **Note**: When the Authorization header is passed and the
            SendEmail is set to `true`, then an email will be sent.  When the
            Authorization header is passed and the SendEmail is set to
            `false`, then an email will not be sent.  When the Authorization
            header is not passed and the SendEmail is set to either `true` or
            `false`, then an email will not be sent.
        waitlist_entry_id (int): The ID of the waiting list entry from which
            you are moving a client into a class.
        client_service_id (int): The ID of the pricing option on the client’s
            account that you want to use to pay for this booking, if payment
            is required at the time of the update.
        cross_regional_booking (bool): When `true`, cross regional series are
            checked and used if applicable.
        cross_regional_booking_client_service_site_id (int): If the request is
            cross regional, use a purchased pricing option from this specified
            site. If omitted, an attempt is made to use an applicable pricing
            option from the local site.
        unique_id (int): The UniqueID of the client who is being booked into
            the class

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "client_id": 'ClientId',
        "class_id": 'ClassId',
        "test": 'Test',
        "require_payment": 'RequirePayment',
        "waitlist": 'Waitlist',
        "send_email": 'SendEmail',
        "waitlist_entry_id": 'WaitlistEntryId',
        "client_service_id": 'ClientServiceId',
        "cross_regional_booking": 'CrossRegionalBooking',
        "cross_regional_booking_client_service_site_id": 'CrossRegionalBookingClientServiceSiteId',
        "unique_id": 'UniqueId'
    }

    _optionals = [
        'test',
        'require_payment',
        'waitlist',
        'send_email',
        'waitlist_entry_id',
        'client_service_id',
        'cross_regional_booking',
        'cross_regional_booking_client_service_site_id',
        'unique_id',
    ]

    def __init__(self,
                 client_id=None,
                 class_id=None,
                 test=APIHelper.SKIP,
                 require_payment=APIHelper.SKIP,
                 waitlist=APIHelper.SKIP,
                 send_email=APIHelper.SKIP,
                 waitlist_entry_id=APIHelper.SKIP,
                 client_service_id=APIHelper.SKIP,
                 cross_regional_booking=APIHelper.SKIP,
                 cross_regional_booking_client_service_site_id=APIHelper.SKIP,
                 unique_id=APIHelper.SKIP):
        """Constructor for the AddClientToClassRequest class"""

        # Initialize members of the class
        self.client_id = client_id 
        self.class_id = class_id 
        if test is not APIHelper.SKIP:
            self.test = test 
        if require_payment is not APIHelper.SKIP:
            self.require_payment = require_payment 
        if waitlist is not APIHelper.SKIP:
            self.waitlist = waitlist 
        if send_email is not APIHelper.SKIP:
            self.send_email = send_email 
        if waitlist_entry_id is not APIHelper.SKIP:
            self.waitlist_entry_id = waitlist_entry_id 
        if client_service_id is not APIHelper.SKIP:
            self.client_service_id = client_service_id 
        if cross_regional_booking is not APIHelper.SKIP:
            self.cross_regional_booking = cross_regional_booking 
        if cross_regional_booking_client_service_site_id is not APIHelper.SKIP:
            self.cross_regional_booking_client_service_site_id = cross_regional_booking_client_service_site_id 
        if unique_id is not APIHelper.SKIP:
            self.unique_id = unique_id 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        client_id = dictionary.get("ClientId") if dictionary.get("ClientId") else None
        class_id = dictionary.get("ClassId") if dictionary.get("ClassId") else None
        test = dictionary.get("Test") if "Test" in dictionary.keys() else APIHelper.SKIP
        require_payment = dictionary.get("RequirePayment") if "RequirePayment" in dictionary.keys() else APIHelper.SKIP
        waitlist = dictionary.get("Waitlist") if "Waitlist" in dictionary.keys() else APIHelper.SKIP
        send_email = dictionary.get("SendEmail") if "SendEmail" in dictionary.keys() else APIHelper.SKIP
        waitlist_entry_id = dictionary.get("WaitlistEntryId") if dictionary.get("WaitlistEntryId") else APIHelper.SKIP
        client_service_id = dictionary.get("ClientServiceId") if dictionary.get("ClientServiceId") else APIHelper.SKIP
        cross_regional_booking = dictionary.get("CrossRegionalBooking") if "CrossRegionalBooking" in dictionary.keys() else APIHelper.SKIP
        cross_regional_booking_client_service_site_id = dictionary.get("CrossRegionalBookingClientServiceSiteId") if dictionary.get("CrossRegionalBookingClientServiceSiteId") else APIHelper.SKIP
        unique_id = dictionary.get("UniqueId") if dictionary.get("UniqueId") else APIHelper.SKIP
        # Return an object of this model
        return cls(client_id,
                   class_id,
                   test,
                   require_payment,
                   waitlist,
                   send_email,
                   waitlist_entry_id,
                   client_service_id,
                   cross_regional_booking,
                   cross_regional_booking_client_service_site_id,
                   unique_id)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'client_id={self.client_id!r}, '
                f'class_id={self.class_id!r}, '
                f'test={(self.test if hasattr(self, "test") else None)!r}, '
                f'require_payment={(self.require_payment if hasattr(self, "require_payment") else None)!r}, '
                f'waitlist={(self.waitlist if hasattr(self, "waitlist") else None)!r}, '
                f'send_email={(self.send_email if hasattr(self, "send_email") else None)!r}, '
                f'waitlist_entry_id={(self.waitlist_entry_id if hasattr(self, "waitlist_entry_id") else None)!r}, '
                f'client_service_id={(self.client_service_id if hasattr(self, "client_service_id") else None)!r}, '
                f'cross_regional_booking={(self.cross_regional_booking if hasattr(self, "cross_regional_booking") else None)!r}, '
                f'cross_regional_booking_client_service_site_id={(self.cross_regional_booking_client_service_site_id if hasattr(self, "cross_regional_booking_client_service_site_id") else None)!r}, '
                f'unique_id={(self.unique_id if hasattr(self, "unique_id") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'client_id={self.client_id!s}, '
                f'class_id={self.class_id!s}, '
                f'test={(self.test if hasattr(self, "test") else None)!s}, '
                f'require_payment={(self.require_payment if hasattr(self, "require_payment") else None)!s}, '
                f'waitlist={(self.waitlist if hasattr(self, "waitlist") else None)!s}, '
                f'send_email={(self.send_email if hasattr(self, "send_email") else None)!s}, '
                f'waitlist_entry_id={(self.waitlist_entry_id if hasattr(self, "waitlist_entry_id") else None)!s}, '
                f'client_service_id={(self.client_service_id if hasattr(self, "client_service_id") else None)!s}, '
                f'cross_regional_booking={(self.cross_regional_booking if hasattr(self, "cross_regional_booking") else None)!s}, '
                f'cross_regional_booking_client_service_site_id={(self.cross_regional_booking_client_service_site_id if hasattr(self, "cross_regional_booking_client_service_site_id") else None)!s}, '
                f'unique_id={(self.unique_id if hasattr(self, "unique_id") else None)!s})')
