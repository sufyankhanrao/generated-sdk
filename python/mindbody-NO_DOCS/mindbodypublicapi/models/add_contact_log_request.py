# -*- coding: utf-8 -*-

"""
mindbodypublicapi

This file was automatically generated by APIMATIC v3.0 (
 https://www.apimatic.io ).
"""
from mindbodypublicapi.api_helper import APIHelper
from mindbodypublicapi.models.add_contact_log_type import AddContactLogType


class AddContactLogRequest(object):

    """Implementation of the 'AddContactLogRequest' model.

    Attributes:
        client_id (str): The ID of the client whose contact log is being added.
        assigned_to_staff_id (int): The ID of the staff member to whom the
            contact log is assigned.
        text (str): The body of the contact log.
        followup_by_date (datetime): The date by which the assigned staff
            member should complete this contact log.
        contact_method (str): How the client wants to be contacted.
        contact_name (str): The name of the person to be contacted by the
            assigned staff member.
        is_complete (bool): When `true`, indicates that the contact log is
            complete.  When `false`, indicates the contact log isn’t complete.
        comments (List[str]): Any comments on the contact log.
        types (List[AddContactLogType]): The contact log types used to tag
            this contact log.
        test (bool): When `true`, indicates that this is a test request and no
            data is inserted into the subscriber’s database.<br />  When
            `false`, the database is updated.

    """

    # Create a mapping from Model property names to API property names
    _names = {
        "client_id": 'ClientId',
        "contact_method": 'ContactMethod',
        "assigned_to_staff_id": 'AssignedToStaffId',
        "text": 'Text',
        "followup_by_date": 'FollowupByDate',
        "contact_name": 'ContactName',
        "is_complete": 'IsComplete',
        "comments": 'Comments',
        "types": 'Types',
        "test": 'Test'
    }

    _optionals = [
        'assigned_to_staff_id',
        'text',
        'followup_by_date',
        'contact_name',
        'is_complete',
        'comments',
        'types',
        'test',
    ]

    def __init__(self,
                 client_id=None,
                 contact_method=None,
                 assigned_to_staff_id=APIHelper.SKIP,
                 text=APIHelper.SKIP,
                 followup_by_date=APIHelper.SKIP,
                 contact_name=APIHelper.SKIP,
                 is_complete=APIHelper.SKIP,
                 comments=APIHelper.SKIP,
                 types=APIHelper.SKIP,
                 test=APIHelper.SKIP):
        """Constructor for the AddContactLogRequest class"""

        # Initialize members of the class
        self.client_id = client_id 
        if assigned_to_staff_id is not APIHelper.SKIP:
            self.assigned_to_staff_id = assigned_to_staff_id 
        if text is not APIHelper.SKIP:
            self.text = text 
        if followup_by_date is not APIHelper.SKIP:
            self.followup_by_date = APIHelper.apply_datetime_converter(followup_by_date, APIHelper.RFC3339DateTime) if followup_by_date else None 
        self.contact_method = contact_method 
        if contact_name is not APIHelper.SKIP:
            self.contact_name = contact_name 
        if is_complete is not APIHelper.SKIP:
            self.is_complete = is_complete 
        if comments is not APIHelper.SKIP:
            self.comments = comments 
        if types is not APIHelper.SKIP:
            self.types = types 
        if test is not APIHelper.SKIP:
            self.test = test 

    @classmethod
    def from_dictionary(cls,
                        dictionary):
        """Creates an instance of this model from a dictionary

        Args:
            dictionary (dictionary): A dictionary representation of the object
            as obtained from the deserialization of the server's response. The
            keys MUST match property names in the API description.

        Returns:
            object: An instance of this structure class.

        """

        if not isinstance(dictionary, dict) or dictionary is None:
            return None

        # Extract variables from the dictionary
        client_id = dictionary.get("ClientId") if dictionary.get("ClientId") else None
        contact_method = dictionary.get("ContactMethod") if dictionary.get("ContactMethod") else None
        assigned_to_staff_id = dictionary.get("AssignedToStaffId") if dictionary.get("AssignedToStaffId") else APIHelper.SKIP
        text = dictionary.get("Text") if dictionary.get("Text") else APIHelper.SKIP
        followup_by_date = APIHelper.RFC3339DateTime.from_value(dictionary.get("FollowupByDate")).datetime if dictionary.get("FollowupByDate") else APIHelper.SKIP
        contact_name = dictionary.get("ContactName") if dictionary.get("ContactName") else APIHelper.SKIP
        is_complete = dictionary.get("IsComplete") if "IsComplete" in dictionary.keys() else APIHelper.SKIP
        comments = dictionary.get("Comments") if dictionary.get("Comments") else APIHelper.SKIP
        types = None
        if dictionary.get('Types') is not None:
            types = [AddContactLogType.from_dictionary(x) for x in dictionary.get('Types')]
        else:
            types = APIHelper.SKIP
        test = dictionary.get("Test") if "Test" in dictionary.keys() else APIHelper.SKIP
        # Return an object of this model
        return cls(client_id,
                   contact_method,
                   assigned_to_staff_id,
                   text,
                   followup_by_date,
                   contact_name,
                   is_complete,
                   comments,
                   types,
                   test)

    def __repr__(self):
        return (f'{self.__class__.__name__}('
                f'client_id={self.client_id!r}, '
                f'assigned_to_staff_id={(self.assigned_to_staff_id if hasattr(self, "assigned_to_staff_id") else None)!r}, '
                f'text={(self.text if hasattr(self, "text") else None)!r}, '
                f'followup_by_date={(self.followup_by_date if hasattr(self, "followup_by_date") else None)!r}, '
                f'contact_method={self.contact_method!r}, '
                f'contact_name={(self.contact_name if hasattr(self, "contact_name") else None)!r}, '
                f'is_complete={(self.is_complete if hasattr(self, "is_complete") else None)!r}, '
                f'comments={(self.comments if hasattr(self, "comments") else None)!r}, '
                f'types={(self.types if hasattr(self, "types") else None)!r}, '
                f'test={(self.test if hasattr(self, "test") else None)!r})')

    def __str__(self):
        return (f'{self.__class__.__name__}('
                f'client_id={self.client_id!s}, '
                f'assigned_to_staff_id={(self.assigned_to_staff_id if hasattr(self, "assigned_to_staff_id") else None)!s}, '
                f'text={(self.text if hasattr(self, "text") else None)!s}, '
                f'followup_by_date={(self.followup_by_date if hasattr(self, "followup_by_date") else None)!s}, '
                f'contact_method={self.contact_method!s}, '
                f'contact_name={(self.contact_name if hasattr(self, "contact_name") else None)!s}, '
                f'is_complete={(self.is_complete if hasattr(self, "is_complete") else None)!s}, '
                f'comments={(self.comments if hasattr(self, "comments") else None)!s}, '
                f'types={(self.types if hasattr(self, "types") else None)!s}, '
                f'test={(self.test if hasattr(self, "test") else None)!s})')
